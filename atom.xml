<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鹏飞Daniel的技术足迹</title>
  <icon>https://www.gravatar.com/avatar/562d6542a2f4370b217e6d00cb9ce78b</icon>
  <subtitle>尔曹身与名俱灭,不废江河万古流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://danielpf.me/"/>
  <updated>2022-07-07T08:03:30.169Z</updated>
  <id>https://danielpf.me/</id>
  
  <author>
    <name>鹏飞Daniel</name>
    <email>dipengfei1982@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>型变浅析</title>
    <link href="https://danielpf.me/2022/07/05/variance-simple-analysis/"/>
    <id>https://danielpf.me/2022/07/05/variance-simple-analysis/</id>
    <published>2022-07-05T10:53:33.000Z</published>
    <updated>2022-07-07T08:03:30.169Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合示例代码简要介绍范型(Generics)及其可变性(Variance)的背景、定义，以及在Java与Kotlin中的不同表现，进而探讨类型擦除(Type Erasure)与Spring对范型依赖的处理(Spring<br>Generics Dependency)等高级主题。</p><a id="more"></a><h3 id="关键字-Key-Words"><a href="#关键字-Key-Words" class="headerlink" title="关键字(Key Words)"></a>关键字(Key Words)</h3><p>本文将涉及以下关键字：</p><ul><li>面向对象编程的三大原则(<a href="https://www.d.umn.edu/~gshute/softeng/presentations/oo-principles.xhtml" target="_blank" rel="noopener">OOP 3 Principles</a>)<ul><li>封装性(Encapsulation)</li><li>继承性(Inheritance)</li><li>多态性(Polymorphism)</li></ul></li><li>软件系统设计的三大原则(Software Design 3 Principles)<ul><li>开-闭原则(<a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" target="_blank" rel="noopener">OCP</a>)</li><li>里氏代换原则(<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">LSP</a>)</li><li>依赖倒转原则(<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">DIP</a>)</li></ul></li><li>时机(Timing)<ul><li>编译时(compile-time)</li><li>运行时(runtime)</li></ul></li><li>PECS<ul><li>Producer -&gt; Extends</li><li>Consumer -&gt; Super</li></ul></li><li>型变(Variance)<ul><li>协变(Covariance)</li><li>逆变(Contravariance)</li><li>不变(invariance)</li></ul></li><li>型变位置(Variance Site)<ul><li>声明处型变(Declaration-site variance)<ul><li>Consumer -&gt; in,</li><li>Producer -&gt; out</li></ul></li><li>使用处型变(Use-site variance)<ul><li>投影(Projections)<ul><li>类型投影(Type Projections)</li><li>星投影(Star Projections)</li></ul></li></ul></li></ul></li><li>类型擦除(Type Erasure)</li></ul><h3 id="型变定义"><a href="#型变定义" class="headerlink" title="型变定义"></a>型变定义</h3><p>这里我们给出一个基于LSP的型变定义。</p><blockquote><p>给定基类<em>Base</em>，记作<em>B</em>，<em>B</em>的派生类<em>Derived</em>，记作<em>D</em>，二者满足LSP，记作<em>B &gt; D</em>。给定映射关系<em>R</em>，分别作用于<em>B</em>、<em>D</em>，得到<em>R(B)</em>、<em>R(D)</em>，</p><ul><li>如果得到R(B) &gt; R(D)，那么关系R为协变(Covariant)的;</li><li>如果得到R(B) &lt; R(D)，那么关系R为逆变(Contravariant)的;</li><li>如果得到R(B) &lt;&gt; R(D)，那么关系R为不型变(Invariant)的。</li></ul></blockquote><p>在本文中讨论的范围内，关系R主要表现为</p><ul><li>数组(Array)</li><li>范型(Generics)</li></ul><h3 id="Java中的型变"><a href="#Java中的型变" class="headerlink" title="Java中的型变"></a>Java中的型变</h3><p>在Java中，数组(Array)被设计成协变(Covariance)的，而范型(Generics)被设计成不变(Invariant)的，下面我们会举例说明这样设计的优缺点。<br>首先看数组(Array)，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// it can be compiled, as Array in Java is covariant, upper cast is ok</span></span><br><span class="line">Object[] objs = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayStoreException occurrs!</span></span><br><span class="line">objs[<span class="number">0</span>] = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，数组(Array)被设计成协变(Covariant)的，有以下优点(Pros)：</p><ul><li>是符合直觉的(intuitive)。</li><li>变量、参数可以灵活(flexibility)地接收字类型实体。</li></ul><p>但也存在缺点(Cons)：</p><ul><li>在某些操作下，类型安全(type safe)会被破坏。</li></ul><p>接下来再看范型(Generics)，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoorBox</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// can't compile, as Generics is invariant.</span></span><br><span class="line">PoorBox&lt;Number&gt; numberPoorBox = <span class="keyword">new</span> PoorBox&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，范型(Generics)被设计成不型变(Invariant)的，与数组(Array)相比，优缺点刚好相反，缺点(Cons)：</p><ul><li>反直觉(counterintuitive)。</li><li>变量、参数丧失灵活性。</li></ul><p>优点(Pros)么：</p><ul><li>类型安全(type safe)得以保证。</li></ul><p>综合数组(Array)与范型(Generics)，类型被设计为协变(Covariant)的,可以保证足够的足够的灵活性(flexibility)，但需要在类型安全(type safe)做出额外考量。而类型安全(type safe)<br>又与特定的<em>操作</em>有关。</p><p>为保证类型安全(type safe)，Java引入边界通配符(Bounded Wild Cards)来增强范型(Generics)系统：</p><ul><li><em>B&lt;? extends T&gt;</em>使当前类型<em>B</em>在参数<em>T</em>上是协变(Covariance)的，编译器保证只能读取(read)类型<em>B</em>中的数据，这时类型<em>B</em>只能为生产者(producer);</li><li><em>B&lt;? super T&gt;</em>使当前类型<em>B</em>在参数<em>T</em>上是逆变(Contravariant)的，编译器保证只能读取(write)类型<em>B</em>中的数据，这时类型<em>B</em>只能为消费者(consumer)。</li></ul><p>以上信息概括起来，就是<em>PECS*原则，以下内容引用自Effective Java, 3rd Edition, Item 31: *Use bounded wildcards to increase API flexibility</em>.</p><blockquote><p>For maximum flexibility, use wildcard types on input parameters that represent producers or consumers. If an input<br>parameter is both a producer and a consumer, then wildcard types will do you no good: you need an exact type match,<br>which is what you get without any wildcards. Here is a mnemonic to help you remember which wildcard type to use:<br><strong><em>PECS stands for producer-extends, consumer-super.</em></strong></p></blockquote><p>下面示例中的<em>copyFrom</em>与<em>copyTo</em>方法依照<em>PECS</em>原则创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoorBox</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T t)</span> </span>&#123;<span class="keyword">this</span>.value = t;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(PoorBox&lt;? extends T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = source.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyTo</span><span class="params">(PoorBox&lt;? <span class="keyword">super</span> T&gt; dest)</span> </span>&#123;</span><br><span class="line">        dest.setValue(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kotlin中的型变"><a href="#Kotlin中的型变" class="headerlink" title="Kotlin中的型变"></a>Kotlin中的型变</h3><p>Kotlin按照自己的设计思路，结合Java语言中范型(Generics)系统的优缺点，给出了自己的实现方式。</p><ol><li>Kotlin把数组也设计成了范型类，统一了设计思路，避免使用两套不同的规则。</li><li>Kotlin引入了<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html" target="_blank" rel="noopener">Nothing</a><br>类，为所有类型设定了一个下界。</li><li>Kotlin引入了<em>声明处型变(Declaration-site variance)</em>，使得符合<em>PECS</em>原则的类型，在声明处即可获得型变。</li><li>Kotlin引入了<em>使用处型变(Use-site variance)</em>和<em>类型投影(Type Projections)</em>，使得不符合<em>PECS</em>原则的类型，在使用处(作为函数参数)即可获得型变。其中<em>星投影</em>比较特殊，即便对类型一无所知，在使用<em>星投影</em>时，仍然可以保证类型安全，因为<em>星投影</em>会限制读写：<ul><li>对于<strong>协变(Covariant)</strong>类型T&lt;out E : Upper&gt;，T&lt;*&gt;相当于T&lt;out Upper&gt;，从T&lt;*&gt;中读取值一定是安全的，但类型会上转型至E的上界，如果E没有上界，会上转型至Any?。</li><li>对于<strong>逆变(Contravariant)</strong>类型T&lt;in E&gt;，T&lt;*&gt;相当于T&lt;in Nothing&gt;，这时无法向T&lt;*&gt;中写入任何值，因为Nothing无法被实例化。</li><li>对于<strong>不变(Invariant)</strong>类型T&lt;E : Upper&gt;，读取时相当于T&lt;out Upper&gt;，写入时相当于T&lt;in Nothing&gt;。</li></ul></li><li>Kotlin引入了<em>泛型约束(Generic constraints)</em>，相比于Java的类型上界(upper bound)只能指定单一上界，Kotlin中可以定义多个上界(upper bound)<br>，这在约束类型实现多个接口时十分有用。</li></ol><blockquote><p>注意，这里说Nothing是所有类型的下界，而不是子类，并且Nothing不能被实例化。与<em>星投影</em>类似，<em>Nothing</em>在编译后，也会被编译成?类型，类似Java语言中的<em>Raw Type</em>。</p></blockquote><p>根据上面的论述，我们可以依照LSP来总结一下Kotlin中的型变规则。<br>给定范型T&lt;E&gt;，以及具体类型String、Number、Int和Any?，那么</p><ol><li>无论T在E上是协变、逆变或不变，都有T&lt;*&gt; = T&lt;Nothing&gt; = T&lt;?&gt;，而T&lt;?&gt; &gt; T&lt;Other&gt;, Other = String、Number、Int以及Any?。</li><li>假设T在E上是<strong>协变(Covariant)</strong>的，则T&lt;Any?&gt; &gt; T&lt;Number&gt; &gt; T&lt;Int&gt;，T&lt;Any?&gt; &gt; T&lt;String&gt;。</li><li>假设T在E上是<strong>逆变(Contravariant)</strong>的，则T&lt;Any?&gt; &lt; T&lt;Number&gt; &lt; T&lt;Int&gt;，T&lt;Any?&gt; &lt; T&lt;String&gt;。</li><li>假设T在E上是<strong>不变(Invariant)</strong>的，则T&lt;Any?&gt;、T&lt;Number&gt;、T&lt;Int&gt;和T&lt;String&gt;无大小判定关系。</li></ol><h3 id="类型擦除-Type-Erasure"><a href="#类型擦除-Type-Erasure" class="headerlink" title="类型擦除(Type Erasure)"></a>类型擦除(Type Erasure)</h3><p>作为构建于JVM之上的编程语言，Java和Kotlin都无法避免<em>类型擦除(Type Erasure)</em>。为保证类型安全，基于范型(Generics)的类型检查，只发生在编译时(compile-time)，运行时(runtime)<br>泛型类型的实例不保留关于其类型实参的任何信息。因此，我们无法在Java中使用<em>instanceof</em>或者在Kotlin中使用<em>is</em>来在运行时(runtime)检测一个泛型类型的实例是否通过指定类型参数所创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// you can only do this</span></span><br><span class="line"><span class="keyword">if</span> (integerBox <span class="keyword">instanceof</span> Box) &#123;&#125;</span><br><span class="line"><span class="comment">// but can not do this</span></span><br><span class="line"><span class="keyword">if</span> (integerBox <span class="keyword">instanceof</span> Box&lt;Integer&gt;) &#123;&#125;</span><br></pre></td></tr></table></figure><p>除此之外，转型(casting)时，虽然可以转型至范型类型，编译器会对非受检类型转换发出警告，因为这种转型(casting)有可能时不安全的。在实际使用中，为避免运行时出现<em>ClassCastException</em>，可以借助<em>TypeReference</em>，很多库都会提供类似功能，例如jackson，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"value\" : 1.5&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> objectMapper = ...;</span><br><span class="line"><span class="keyword">var</span> doublePoorBox = objectMapper.readValue(json, <span class="keyword">new</span> TypeReference&lt;PoorBox&lt;Double&gt;&gt;() &#123;&#125;);</span><br></pre></td></tr></table></figure><p>Spring中的<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener">RestTemplate</a>也有类似的用法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;PoorBox&lt;Double&gt;&gt; response = </span><br><span class="line">       restTemplate.exchange(url, httpMethod.POST, requestEntity, </span><br><span class="line">               <span class="keyword">new</span> ParameterizedTypeReference&lt;PoorBox&lt;Double&gt;&gt;()&#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="范型依赖-Generics-Dependency"><a href="#范型依赖-Generics-Dependency" class="headerlink" title="范型依赖(Generics Dependency)"></a>范型依赖(Generics Dependency)</h3><p>Spring中支持注入范型Bean，并充分支持型变(Variance)。例如注入List时，Spring会根据范型参数和型变来过滤候选Bean。以下为简单的示例，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generics class, Declaration-site variance, out -&gt; covariant</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutBox</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> value: T)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">intOutBox</span><span class="params">()</span></span> = OutBox(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numberOutBox</span><span class="params">()</span></span> = OutBox&lt;Number&gt;(<span class="number">2.5</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stringOutBox</span><span class="params">()</span></span> = OutBox(<span class="string">"out"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxBeansHolder</span></span>(</span><br><span class="line">    <span class="keyword">val</span> intOutBoxList: List&lt;OutBox&lt;<span class="built_in">Int</span>&gt;&gt;, <span class="comment">// 1 bean injected: OutBox&lt;Number&gt;</span></span><br><span class="line">    <span class="keyword">val</span> numberOutBoxList: List&lt;OutBox&lt;Number&gt;&gt;, <span class="comment">// 2 beans injected: OutBox&lt;Number&gt;, OutBox&lt;Int&gt; </span></span><br><span class="line">    <span class="keyword">val</span> anyOutBoxList: List&lt;OutBox&lt;Any?&gt;&gt; <span class="comment">// 3 beans injected: OutBox&lt;Number&gt;, OutBox&lt;Int&gt;, OutBox&lt;String&gt;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>范型(Generics)几乎是每种高级编程语言需要考虑的特性，而可变性(Variance)又伴随范型(Generics)而生，Java和Kotlin也给出了自己的实现原则。</p><ol><li>范型(Generics)出现在JDK 1.5，Java为支持范型并保证最大的向下兼容性，把范型设计成了编译后类型擦除(Type Erasure)，在可变性(Variance)方面，为保证类型安全，选择了<strong>不型变(invariance)</strong>。</li><li>为保证API的灵活性，Java引入了范型边界和<strong>PECS</strong>原则。</li><li>Kotlin意识到了Java语言在范型(Generics)方面的问题，引入了<strong>声明处型变(Declaration-site variance)</strong>和<strong>使用处型变(Use-site variance)</strong>，总体说来是进步的，但在客观上也增加了语言的复杂性。</li><li>Spring等框架也充分意识到型变(Variance)的重要性，在注入范型Bean时，按照型变原则来判定候选Bean。</li></ol><p>更详细的示例，请参考这个<a href="https://github.com/dipengfei/spring-loves-kt" target="_blank" rel="noopener">代码仓库</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合示例代码简要介绍范型(Generics)及其可变性(Variance)的背景、定义，以及在Java与Kotlin中的不同表现，进而探讨类型擦除(Type Erasure)与Spring对范型依赖的处理(Spring&lt;br&gt;Generics Dependency)等高级主题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://danielpf.me/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="kotlin" scheme="https://danielpf.me/tags/kotlin/"/>
    
      <category term="java" scheme="https://danielpf.me/tags/java/"/>
    
      <category term="variance" scheme="https://danielpf.me/tags/variance/"/>
    
      <category term="generics" scheme="https://danielpf.me/tags/generics/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的SpringBoot (Part 1)</title>
    <link href="https://danielpf.me/2021/04/19/you-dont-know-springboot-01/"/>
    <id>https://danielpf.me/2021/04/19/you-dont-know-springboot-01/</id>
    <published>2021-04-19T13:00:30.000Z</published>
    <updated>2021-04-22T14:41:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着<a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">SpringBoot</a>日渐流行，有关<code>SpringBoot</code>的各类“心经”、“秘籍”、“从入门到精通”之类的文章或者书籍琳琅满目、层出不穷，本文无意与这些典籍争锋，而是从实际应用出发，结合<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/" target="_blank" rel="noopener">官方文档</a>，收集并整理一些不常见却很有用的知识点，同时蹭一下<a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="noopener">You Don’t Know JS Yet</a>的热度，姑且就叫它<code>你不知道的SpringBoot</code>。</p><a id="more"></a><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><a href="https://start.spring.io/" target="_blank" rel="noopener">start.spring.io</a>可以说是最好的<code>SpringBoot</code>项目创建工具，没有之一。<code>start.spring.io</code>可以满足绝大多数创建由<code>SpringBoot</code>驱动的应用程序的场景，它具备以下特征：</p><ol><li>生成的工程开箱即用，几乎不做任何修改就可以运行；</li><li>IDE友好，可以快速导入进主流IDE中；</li><li>依赖版本准确，不会引发依赖不匹配而导致的各类诡异问题，例如<code>SpringBoot</code>与<code>Spring Cloud</code>大版本的匹配都是准确的；</li><li>多构建工具支持，可以自由选择<code>Maven</code>或<code>Gradle</code>；</li><li>多语言支持，可以自由选择<code>Java</code>、<code>Groovy</code>或<code>Kotlin</code>；</li><li>多Java版本支持，可以自由选择<code>LTS</code>或最新版的JDK；</li><li>可以通过<code>Explore</code>功能拷贝需要的依赖代码片段而不需要下载整个项目；</li><li>可以通过<code>Share</code>功能把创建项目的属性以URL的方式分享给其他人。</li></ol><p>除以上特征之外，<code>start.spring.io</code>本身提供了<code>restful API</code>，可以通过简单的<code>http</code>调用来创建项目而不需要访问他的web UI，例如下面的例子，通过<code>curl</code>来创建一个新的项目并下载到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://start.spring.io/starter.zip -d dependencies=web,devtools \</span><br><span class="line">            -d bootVersion=2.3.5.RELEASE -o my-project.zip</span><br></pre></td></tr></table></figure><p>这种API调用的方式也是大多数IDE生成<code>SpringBoot</code>项目的底层手段。除使用<code>curl</code>外，还可以通过<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-cli.html#cli" target="_blank" rel="noopener">Spring Boot CLI</a>的方式创建项目，与<code>curl</code>方式是非类似，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ spring init --build=gradle \ </span><br><span class="line">                --java-version=1.8 --dependencies=websocket  \ </span><br><span class="line">                --packaging=jar sample-app.zip</span><br></pre></td></tr></table></figure><p><code>Spring Boot CLI</code>的安装可以参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-installing-the-cli" target="_blank" rel="noopener">官方文档</a>。</p><p>以上<code>start.spring.io</code>以及其衍生工具的使用，除此之外，我们甚至可以搭建自己的<code>Spring Initializr Reference</code>，原理类似与自己运行一个<code>start.spring.io</code>，这里我们就不展开讨论了。<br>更多详情请参考<a href="https://docs.spring.io/initializr/docs/current/reference/html/" target="_blank" rel="noopener">官方文档</a>，</p><h3 id="内置的构建工具"><a href="#内置的构建工具" class="headerlink" title="内置的构建工具"></a>内置的构建工具</h3><p>如果采用上述<code>start.spring.io</code>生成<code>Maven</code>或<code>Gradle</code>项目时，项目中会自带<a href="https://github.com/takari/maven-wrapper" target="_blank" rel="noopener">Maven Wrapper</a>或<a href="https://docs.gradle.org/current/userguide/gradle_wrapper.html" target="_blank" rel="noopener">Grade Wrapper</a>，以<code>Maven</code>项目为例，我们会在项目下看到下面的目录结构，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── .mvn</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── MavenWrapperDownloader.java</span><br><span class="line">│       ├── maven-wrapper.jar</span><br><span class="line">│       └── maven-wrapper.properties</span><br><span class="line">├── HELP.md</span><br><span class="line">├── mvnw</span><br><span class="line">├── mvnw.cmd</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br></pre></td></tr></table></figure><p>其中的<code>.mvn</code>、<code>mvnw</code>就是项目自带<code>Maven Wrapper</code>。一般我们在使用<code>Maven</code>时，用到的都是提前安装好的全局的<code>Maven</code>，所有需要构建的程序也都会共享这一个全局的<code>Maven</code>。但是对于某些项目来说，构建是可能需要用到特定的<code>Maven</code>版本，这时做全局安装费时费力，还要污染全局，而使用<code>Maven Wrapper</code>就可以避免类似问题，进而高效地使用特定版本的<code>Maven</code>，<code>Maven Wrapper</code>的工作流程是这样的：</p><ol><li>在执行<code>mvnw</code>命令时，会检查<code>/.m2/wrapper</code>目录下是否有对应版本的<code>Maven</code>安装，如果有，则继续构建；</li><li>如果没有，则根据当前目录下<code>.mvn/wrapper/maven-wrapper.properties</code>中的的<code>distributionUrl</code>属性值来下载<code>Maven</code>，下载后再完成构建；</li></ol><p>有很多同学在生成<code>SpringBoot</code>项目后，直接就把<code>Maven Wrapper</code>相关的文件删除掉了，这里还是建议保留，并且也应该把这些文件一并提交到代码仓库里，这样对于其他开发人员和<code>CI/CD</code>工具也是友好的，大家都可以使用一致的环境来构建项目。</p><h3 id="特有的转换器"><a href="#特有的转换器" class="headerlink" title="特有的转换器"></a>特有的转换器</h3><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#core-convert" target="_blank" rel="noopener">Converter SPI</a>是<code>Spring Framework</code>中非常重要的基本概念，<code>Spring Framework</code>也内置转换器可以实现从<code>String</code>到其他常用数据类型的转换。<code>SpringBoot</code>进一步强化了转换器，引入了3个特有的转换器，可以方便的处理<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Duration.html" target="_blank" rel="noopener">Duration</a>、<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Period.html" target="_blank" rel="noopener">Peroid</a>以及<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/unit/DataSize.html" target="_blank" rel="noopener">DataSize</a>，详情如下表所示：</p><table><thead><tr><th align="left">Java类型</th><th align="left">单位</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Duration.html" target="_blank" rel="noopener">java.time.Duration</a></td><td align="left">ns<br/>us<br/>ms<br/>s<br/>m<br/>h<br/>d</td><td align="left">50s<br/>3d</td></tr><tr><td align="left"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Period.html" target="_blank" rel="noopener">java.time.Period</a></td><td align="left">y<br/>m<br/>w<br/>d</td><td align="left">2m<br/>1y3d</td></tr><tr><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/unit/DataSize.html" target="_blank" rel="noopener">org.springframework.util.unit.DataSize</a></td><td align="left">B<br/>KB<br/>MB<br/>GB<br/>TB</td><td align="left">512B<br/>2MB</td></tr></tbody></table><p>完整的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"demo"</span>)</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Duration duration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Period period;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSize dataSize;</span><br><span class="line"></span><br><span class="line">    DemoProperties(<span class="meta">@DefaultValue</span>(<span class="string">"30s"</span>) Duration duration,</span><br><span class="line">                   <span class="meta">@DefaultValue</span>(<span class="string">"2y3d"</span>) Period period,</span><br><span class="line">                   <span class="meta">@DefaultValue</span>(<span class="string">"5MB"</span>) DataSize dataSize) &#123;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">        <span class="keyword">this</span>.period = period;</span><br><span class="line">        <span class="keyword">this</span>.dataSize = dataSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详情请参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config-conversion" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="特有的事件"><a href="#特有的事件" class="headerlink" title="特有的事件"></a>特有的事件</h3><p><code>Spring Framework</code>本身实现了一整套事件体系，并定义了一组内置的<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events" target="_blank" rel="noopener">事件</a>，但这些<code>事件</code>基本上是<code>Context</code>级别的，而不是<code>Application</code>级别的。<code>SpringBoot</code>拓展了<code>Spring Framework</code>的事件体系，并引入了<code>Application Level</code>的一组事件：</p><ol><li>应用程序启动时会触发<code>ApplicationStartingEvent</code>；</li><li>应用程序运行的<code>Environment</code>准备好后，在创建<code>Applicatoin Context</code>之前，会触发<code>ApplicationEnvironmentPreparedEvent</code>；</li><li>在<code>ApplicationContext</code>准备好后，所有<code>ApplicationContextInitializers</code>被执行后，但在所有的<code>Bean</code>定义加载之前，会触发<code>ApplicationContextInitializedEvent</code>事件；</li><li><code>Bean</code>定义加载后，会触发<code>ApplicationPreparedEvent</code>事件；</li><li>在<code>Application Context</code>刷新后，<code>command-line runner</code>被调用之前，会触发<code>ApplicationStartedEvent</code>事件；</li><li>在<code>LivenessState.CORRECT</code>被检测到之后，换言之，应用程序已经被认为处于活跃状态，会触发<code>AvailabilityChangeEvent</code>事件；</li><li>在所有的<code>command-line runner</code>被执行后，会触发<code>ApplicationReadyEvent</code>事件。(原文是“any”而不是“all”，表述不是非常准确，特意提了这个<a href="https://github.com/spring-projects/spring-boot/issues/26180" target="_blank" rel="noopener">issue</a>)；</li><li>在<code>ReadinessState.ACCEPTING_TRAFFIC</code>被简则之后，换言之，应用程序已被认为可以处理外部请求，会再触发<code>AvailabilityChangeEvent</code>事件；</li><li>在应用程序启动过程中产生任何异常，会触发<code>ApplicationFailedEvent</code>事件。</li></ol><p>以上<code>Application Level</code>的各类事件中，最常用的监听<code>ApplicationReadyEvent</code>事件来做其他初始化操作，因为这个时间点，所有的<code>Bean</code>及其依赖都已经创建，这些<code>Bean</code>已经可以使用，例如下面的代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StudentRepo</span> </span>&#123;</span><br><span class="line">    <span class="function">Stream&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StudentRepo studentRepo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Map&lt;Long, Student&gt;&gt; _caches = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span>(ApplicationReadyEvent<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">init</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._caches.set(<span class="keyword">this</span>.studentRepo.findAll()</span><br><span class="line">                                         .collect(Collectors.toConcurrentMap(Student::getId, Function.identity())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详情请参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="运行初始化代码"><a href="#运行初始化代码" class="headerlink" title="运行初始化代码"></a>运行初始化代码</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/CommandLineRunner.html" target="_blank" rel="noopener">CommandLineRunner</a>和<a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/ApplicationRunner.html" target="_blank" rel="noopener">ApplicationRunner</a>都可以用来运行初始化代码，<code>CommandLineRunner</code>通过一个字符串数组来访问命令行参数，而<code>ApplicationRunner</code>是通过<a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/ApplicationArguments.html" target="_blank" rel="noopener">ApplicationArguments</a>来访问。除此之外，可以配置多个<code>CommandLineRunner</code>或者<code>ApplicationRunner</code>，其优先级和执行顺序遵循一下规则：</p><ol><li><code>ApplicationRunner</code>会优先于<code>CommandLineRunner</code>执行；</li><li>多个同类型的<code>Runner</code>可以通过<code>@Order</code>注解来指定运行顺序，但<code>@Order</code>只有放在<code>class</code>上才生效。</li></ol><p>考虑下面的代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incorrect code, don't use it</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"I'm commandline runner 1"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"I'm commandline runner 2"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">10</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">applicationRunner3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"I'm application runner 3"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出结果为，</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.d.y.YouDontKnowSpringbootApplication   : I'm application runner 3</span><br><span class="line">m.d.y.YouDontKnowSpringbootApplication   : I'm commandline runner 1</span><br><span class="line">m.d.y.YouDontKnowSpringbootApplication   : I'm commandline runner 2</span><br></pre></td></tr></table></figure><p>可以看到<code>applicationRunner3</code>最先被运行，但<code>commandLineRunner1</code>与<code>commandLineRunner2</code>并没有按照<code>@Order</code>指定的顺序运行，其中的原理可以参考<a href="https://stackoverflow.com/questions/56331925/sort-spring-beans-by-method-level-order-annotation" target="_blank" rel="noopener">这里</a>。只有按照下面的方式才能做到有序，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandLineRunner1</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"I'm commandline runner 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandLineRunner2</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"I'm commandline runner 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出结果为，</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">me.danielpf.ydtk.CommandLineRunner2      : I'm commandline runner 2</span><br><span class="line">me.danielpf.ydtk.CommandLineRunner1      : I'm commandline runner 1</span><br></pre></td></tr></table></figure><blockquote><p>上面已经提到过，<code>ApplicationReadyEvent</code>会在所有的<code>Runner</code>运行之后才会触发，所以尽量避免既在<code>Runner</code>中执行过长、过慢的逻辑又要依赖于监听<code>ApplicationReadyEvent</code>，考虑下面的代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">pulic CommandLineRunner <span class="title">commandLineRunner</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">     log.info(<span class="string">"start commandline runner..."</span>);</span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EentListener</span>(ApplicationReadyEvent<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">pulic</span> <span class="title">void</span> <span class="title">ready</span>() </span>&#123;</span><br><span class="line">    log.info(<span class="string">"application ready..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其输出结果为，<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-04-21 15:57:32.379  INFO 56531 --- [           main] m.d.y.YouDontKnowSpringbootApplication   : start commandline runner...</span><br><span class="line">2021-04-21 15:57:42.386  INFO 56531 --- [           main] m.d.y.YouDontKnowSpringbootApplication   : application ready...</span><br></pre></td></tr></table></figure><footer><strong>注意</strong></footer></blockquote><p>更多详情请参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-command-line-runner" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="Web-Application类型"><a href="#Web-Application类型" class="headerlink" title="Web Application类型"></a>Web Application类型</h3><p><code>SpringBoot</code>会根据依赖尝试创建合适的<code>Web Environment</code>，其默认规则可以参考下面的表格，</p><table><thead><tr><th align="left">Starter</th><th align="left">Application Conext</th><th align="left">Web Application Type</th><th align="left">Web Container</th></tr></thead><tbody><tr><td align="left"><code>spring-boot-starter-web</code> only</td><td align="left"><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/web/servlet/context/AnnotationConfigServletWebServerApplicationContext.html" target="_blank" rel="noopener">AnnotationConfigServletWebServer</a></td><td align="left"><code>SERVLET</code></td><td align="left">Tomcat</td></tr><tr><td align="left"><code>spring-boot-starter-webflux</code> only</td><td align="left"><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/web/reactive/context/AnnotationConfigReactiveWebServerApplicationContext.html" target="_blank" rel="noopener">AnnotationConfigReactiveWebServer</a></td><td align="left"><code>REACTIVE</code></td><td align="left">Netty</td></tr><tr><td align="left"><code>spring-boot-starter-web</code><br /><code>spring-boot-starter-webflux</code></td><td align="left"><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/web/servlet/context/AnnotationConfigServletWebServerApplicationContext.html" target="_blank" rel="noopener">AnnotationConfigServletWebServer</a></td><td align="left"><code>SERVLET</code></td><td align="left">Tomcat</td></tr><tr><td align="left"><code>spring-boot-starter</code></td><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/AnnotationConfigApplicationContext.html" target="_blank" rel="noopener">AnnotationConfig</a></td><td align="left"><code>NONE</code></td><td align="left">N/A</td></tr></tbody></table><p>需要注意的是，</p><ol><li>如果<code>spring-boot-starter-web</code>与<code>spring-boot-starter-webflux</code>混用，那么<code>Web Environment</code>还是会被设置为<code>SERVLET</code>，这种情况是为了兼容在<code>SERVLET</code>应用中使用<code>Reactive API</code>，例如<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/client/WebClient.html" target="_blank" rel="noopener">WebClient</a>；</li><li>可以通过编程的方式，手动设置<code>WebApplicationType</code>，甚至关闭<code>Web Environment</code>，例如下面的代码是通过<code>flunt-builder</code>的方式关闭<code>Web Environment</code>，</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">            .sources(YouDontKnowSpringbootApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">web</span>(<span class="title">WebApplicationType</span>.<span class="title">NONE</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详情请参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-web-environment" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="使用JSON配置应用"><a href="#使用JSON配置应用" class="headerlink" title="使用JSON配置应用"></a>使用JSON配置应用</h3><p>大多数场景下，我们一般会使用<code>properties</code>文件或者<code>YAML</code>文件，结合命令行参数来配置<code>SpringBoot</code>应用程序，除此之外，我们还可以通过<code>JSON</code>来配置应用程序，我们可以把基于<code>JSON</code>的配置理解成为一个增强版的命令行。我们写在<code>JSON</code>里面的配置，都会被merge进当前的<code>Environment</code>。</p><p><code>JSON</code>配置可以通过以下几种方式传递给应用程序，这里借官方文档的几个示例说明，</p><ol><li>通过<code>UN*X shell</code>的环境变量传递：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ SPRING_APPLICATION_JSON=<span class="string">'&#123;"acme":&#123;"name":"test"&#125;&#125;'</span> java -jar myapp.jar</span><br></pre></td></tr></table></figure></li><li>通过<code>system property</code>传递：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -Dspring.application.json=<span class="string">'&#123;"acme":&#123;"name":"test"&#125;&#125;'</span> -jar myapp.jar</span><br></pre></td></tr></table></figure></li><li>通过命令行参数传递：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar myapp.jar --spring.application.json=<span class="string">'&#123;"acme":&#123;"name":"test"&#125;&#125;'</span></span><br></pre></td></tr></table></figure></li><li>如果应用程序部署在传统的web中间件中，可以通过<code>JNDI</code>传递，变量名称为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java:comp/env/spring.application.json</span><br></pre></td></tr></table></figure></li></ol><p>更多详情请参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config-application-json" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="基于Profile的Logback"><a href="#基于Profile的Logback" class="headerlink" title="基于Profile的Logback"></a>基于Profile的Logback</h3><p>在<code>SpringBoot</code>中使用<code>Logback</code>也能享受到<code>Spring Profile</code>所带来的便利，基于<code>Profile</code>的<code>Logback</code>配置文件为<code>logback-spring.xml</code>，放置在<code>classpath</code>下会被<code>SpringBoot</code>自动加载。<br>我们可以使用<code>springProfile</code>来控制不同<code>Profile</code>下有那些<code>appender</code>会生效，例如这样，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ROLL_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging | prod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"MAILER"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.net.SMTPAppender"</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用<code>springProperty</code>来定义一些属性，并在后面的配置引用这些属性，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">"context"</span> <span class="attr">name</span>=<span class="string">"mailSubjectPrefix"</span> <span class="attr">source</span>=<span class="string">"mail.subject.prefix"</span> <span class="attr">defaultValue</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">"context"</span> <span class="attr">name</span>=<span class="string">"component"</span> <span class="attr">source</span>=<span class="string">"mail.component"</span> <span class="attr">defaultValue</span>=<span class="string">"[my-app]"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">name</span>=<span class="string">"LOG_PATH"</span> <span class="attr">source</span>=<span class="string">"logging.path"</span> <span class="attr">defaultValue</span>=<span class="string">"/var/log/my-app/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">name</span>=<span class="string">"LOG_FILE"</span> <span class="attr">source</span>=<span class="string">"logging.path"</span> <span class="attr">defaultValue</span>=<span class="string">"main"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>更多详情请参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-logback-extensions" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="探活"><a href="#探活" class="headerlink" title="探活"></a>探活</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-enabling" target="_blank" rel="noopener">Spring Boot Actuator</a>提供了非常强大的系统监控功能。在K8s等容器环境部署<code>SpringBoot</code>应用时，我们可以可以借助<code>Spring Boot Actuator</code>内置的<code>Health Indicator</code>来实现探活，一般情况下借助<code>/actuator/health/liveness</code>与<code>/actuator/health/readiness</code>这两个endpoint，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health/liveness</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&lt;actuator-port&gt;</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health/readiness</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&lt;actuator-port&gt;</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure><p>我们还可以实现自己的<code>HealthIndicators</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.Health;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> errorCode = check(); <span class="comment">// perform some specific health check</span></span><br><span class="line">        <span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down().withDetail(<span class="string">"Error Code"</span>, errorCode).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.up().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详情请参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-kubernetes-probes" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h3><p>在检测到有数据库访问相关的依赖后，<code>SpringBoot</code>会尝试<code>Auto Config</code>数据源，我们只需要设定数据源的各类属性即可。但在某些业务场景下，我们需要多个数据源，我们可以借助<code>SpringBoot</code>内置的一些工具，比较方便地配置多个数据源。下面的代码展示了从配置上彻底分开的两个不同数据源，</p><pre><code class="java"><span class="meta">@Bean</span><span class="meta">@Primary</span><span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.first"</span>)<span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">firstDataSourceProperties</span><span class="params">()</span> </span>{    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();}<span class="meta">@Bean</span><span class="meta">@Primary</span><span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.first.configuration"</span>)<span class="function"><span class="keyword">public</span> HikariDataSource <span class="title">firstDataSource</span><span class="params">()</span> </span>{    <span class="keyword">return</span> firstDataSourceProperties().initializeDataSourceBuilder().type(HikariDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;}<span class="meta">@Bean</span><span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.second"</span>)<span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">secondDataSourceProperties</span><span class="params">()</span> </span>{    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();}<span class="meta">@Bean</span><span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource.second.configuration"</span>)<span class="function"><span class="keyword">public</span> BasicDataSource <span class="title">secondDataSource</span><span class="params">()</span> </span>{    <span class="keyword">return</span> secondDataSourceProperties().initializeDataSourceBuilder().type(BasicDataSource<span class="class">.<span class="keyword">class</span>).<span class="title">build</span>()</span>;}</code></pre><p>上述代码的要点如下：</p><ol><li>可以借助<a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.html" target="_blank" rel="noopener">DataSourceProperties</a>来绑定特定前缀的数据源属性(这些属性仍为标准属性，只是前缀不同)，并通过<code>initializeDataSourceBuilder()</code>和<code>type()</code>创建特定类型的数据源；</li><li>可以借助<code>@ConfigurationProperties</code>再次将自定义的属性绑定到已经在上一步创建的数据源对象上；</li><li>一定要通过<code>@Primary</code>来指定默认的数据源。</li></ol><p>关于多数据源的动态切换，不在本文做过多讨论，可以参考这篇<a href="https://spring.io/blog/2007/01/23/dynamic-datasource-routing/" target="_blank" rel="noopener">Blog</a>。<br>更多详情请参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-two-datasources" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着&lt;a href=&quot;https://spring.io/projects/spring-boot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringBoot&lt;/a&gt;日渐流行，有关&lt;code&gt;SpringBoot&lt;/code&gt;的各类“心经”、“秘籍”、“从入门到精通”之类的文章或者书籍琳琅满目、层出不穷，本文无意与这些典籍争锋，而是从实际应用出发，结合&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/html/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;，收集并整理一些不常见却很有用的知识点，同时蹭一下&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;You Don’t Know JS Yet&lt;/a&gt;的热度，姑且就叫它&lt;code&gt;你不知道的SpringBoot&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="https://danielpf.me/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="spring" scheme="https://danielpf.me/tags/spring/"/>
    
      <category term="springboot" scheme="https://danielpf.me/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin + Spring Cloud Stream构建实时消息系统</title>
    <link href="https://danielpf.me/2020/10/05/reactive-messaging-kt/"/>
    <id>https://danielpf.me/2020/10/05/reactive-messaging-kt/</id>
    <published>2020-10-05T14:19:22.000Z</published>
    <updated>2020-10-05T07:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一门新兴的现代化编程语言，<a href="https://kotlinlang.org/" target="_blank" rel="noopener">Kotlin</a>正获得广泛的关注，<a href="https://spring.io/" target="_blank" rel="noopener">Spring</a>社区也将支持<code>Kotlin</code>语言作为下一阶段的<a href="https://blog.jetbrains.com/kotlin/2020/08/the-state-of-kotlin-support-in-spring/" target="_blank" rel="noopener">重要工作</a>，甚至抛出了<a href="https://speakerdeck.com/sdeleuze/why-spring-loves-kotlin" target="_blank" rel="noopener">Spring Loves Kotin</a>和<a href="https://kotlin.link/articles/Spring-Boot-and-Kotlin-a-match-made-in-Heaven.html" target="_blank" rel="noopener">A Match Made in Heaven</a>这般暧昧的论调。本文暂不去讨论<code>Kotlin</code>语言的细节，而是通过使用<code>Kotlin</code>和<a href="https://spring.io/projects/spring-cloud-stream" target="_blank" rel="noopener">Spring Cloud Stream</a>构建实时消息系统来领略一番<code>Spring Loves Kotlin</code>的魅力。</p><a id="more"></a><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><code>实时消息系统</code>可适用于多种业务场景，本文将实现一个非常典型的案例，其它复杂案例都可以通过此案例扩展，其架构如下图所示：</p><pre class="mermaid">graph LR;    A(1.Producer)-->|MQ|B(2.Processor);    B-->|MQ|C(3.Consumer);    C-->|Pub-Sub|D(4.Notifier);    D-->|Http|E((5.Client));</pre><p>下面对各模块进行简要说明，</p><ol><li><code>Producer</code>: 作为数据源产生数据，并将数据通过<code>MQ</code>传给后面的<code>Processor</code>进行处理;</li><li><code>Processor</code>: 在<code>MQ</code>中读取<code>Producer</code>产生的消息并加以处理，并将处理后的结果通过<code>MQ</code>传给后面的<code>Consumer</code>;</li><li><code>Consumer</code>: 在<code>MQ</code>中读取<code>Processor</code>产生的消息并转发至<code>Redis</code>中的<code>Pub-Sub Topic</code>;</li><li><code>Notifier</code>: 订阅<code>Redis</code>中的<code>Pub-Sub Topic</code>并处理由<code>Consumer</code>发布的消息，并通过<code>SSE</code>转发给订阅消息的<code>Client</code>;</li><li><code>Client</code>: 通过<code>Http</code>订阅由<code>Notifier</code>发布的<code>SSE</code>事件;</li></ol><p>本文中的案例将会实现模块1～4，模块5<code>Client</code>不做实现，可通过<code>curl</code>等http客户端进行模拟。</p><h3 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h3><p>按照上面讨论的系统架构，我们创建一个多模块的<a href="https://gradle.org/" target="_blank" rel="noopener">Gradle</a>项目，并用<a href="https://docs.gradle.org/current/userguide/kotlin_dsl.html" target="_blank" rel="noopener">Kotlin DSL</a>作为描述语言，<a href="https://github.com/dipengfei/reactive-messaging-kt" target="_blank" rel="noopener">项目</a>结构如下图所示：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">├── rmkt-consumer</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── build.gradle.kts</span><br><span class="line">├── rmkt-core</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── build.gradle.kts</span><br><span class="line">├── rmkt-notifier</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── build.gradle.kts</span><br><span class="line">├── rmkt-processor</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── build.gradle.kts</span><br><span class="line">├── rmkt-producer</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── build.gradle.kts</span><br><span class="line">├── HELP.md</span><br><span class="line">├── README.md</span><br><span class="line">├── build.gradle.kts</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">└── settings.gradle.kts</span><br></pre></td></tr></table></figure><p>这些模块都可以与上面讨论过的<a href="#系统架构">系统架构</a>一一对应，唯一的不同点是项目中多出了一个<code>core</code>模块，该模块用于放置各模块的公用部分，例如<code>domain</code>对象、<code>常量定义</code>以及<code>公共方法</code>等，稍后我们会详细说明。本文不会讨论<code>Kotlin DSL</code>的细节，由于没有涉及过多的知识点，各模块的<code>build.gradle.kts</code>文件(类似于<code>Maven</code>中的<code>pom.xml</code>文件)应该不会影响大家对代码的理解。</p><p>下面简要说明一下该系统的业务逻辑：</p><ol><li><code>Producter</code>每隔1秒钟产生一个<code>Product</code>消息，每个<code>Product</code>包含唯一的<code>id</code>和随机产生的<code>name</code>、<code>price</code>以及<code>createdTime</code>;</li><li><code>Processor</code>处理<code>Product</code>消息，根据预先定义的<code>ExchangeRate</code>来计算<code>Product</code>在多种货币下的价格，并生成<code>ProductExchange</code>对象;</li><li><code>Consumer</code>收到<code>ProductExchange</code>对象后，过滤价格小于<code>500</code>的，并将其转发至<code>Redis</code>的<code>Pub-Sub Topic</code>中;</li><li><code>Notifier</code>订阅<code>Pub-Sub Topic</code>，并将<code>ProductExchange</code>按照<code>Client</code>请求的货币种类转换成<code>ProductLocal</code>对象，并以<code>SSE</code>事件的形式返回给<code>Client</code>.</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>接下来我们根据上面讨论的系统架构、项目模块以及业务逻辑来实现代码。</p><h4 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h4><p>功能模块的公共部分都放置在<code>Core模块</code>内，我们可以在<a href="https://github.com/dipengfei/reactive-messaging-kt/blob/main/rmkt-core/src/main/kotlin/me/danielpf/rmkt/core/Core.kt" target="_blank" rel="noopener">Core.kt</a>文件里定义功能模块所需的domain、常量以及工具类。首先我们先使用<code>Kotlin</code>的特性之一，<a href="https://kotlinlang.org/docs/reference/data-classes.html" target="_blank" rel="noopener">数据类</a>来构建<code>Product</code>和<code>ProductExchange</code>，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: String, </span><br><span class="line">    <span class="keyword">val</span> name: String, </span><br><span class="line">    <span class="keyword">val</span> price: <span class="built_in">Double</span>, </span><br><span class="line">    <span class="keyword">val</span> createdTime: LocalDateTime</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductExchange</span></span>(</span><br><span class="line">    <span class="keyword">val</span> product: Product, </span><br><span class="line">    <span class="keyword">val</span> localPrices: Map&lt;String, <span class="built_in">Double</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后再使用<a href="https://kotlinlang.org/docs/reference/enum-classes.html" target="_blank" rel="noopener">枚举类</a>构建<code>ExchangeRate</code>，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeRate</span></span>(<span class="keyword">val</span> rate: <span class="built_in">Double</span>) &#123;</span><br><span class="line">    USD(<span class="number">1.00</span>),</span><br><span class="line">    CNY(<span class="number">6.7906</span>),</span><br><span class="line">    JPY(<span class="number">105.3246</span>),</span><br><span class="line">    EUR(<span class="number">0.8535</span>),</span><br><span class="line">    GBP(<span class="number">0.773</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们再使用<a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects" target="_blank" rel="noopener">伴生对象</a>来模拟<code>Java</code>中的常量定义，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> PRODUCT_EXCHANGE_TOPIC = <span class="string">"topic:pe"</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> DEFAULT_CURRENCY = <span class="string">"USD"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们再使用<a href="https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations" target="_blank" rel="noopener">对象声明</a>来实现一个<code>单例模式</code>，这是一个单例的<code>ObjectMapper</code>，预定义了一些特性，可用于后续的JSON对象的序列化/反序列化，需要使用该对象的时候，只需要使用<code>ObjectMapperExtension.instance</code>即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ObjectMapperExtension &#123;</span><br><span class="line">    <span class="keyword">val</span> instance: ObjectMapper = jacksonObjectMapper()</span><br><span class="line">        .registerModules(Jdk8Module(), JavaTimeModule())</span><br><span class="line">        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><p>接下来我们将借助<a href="https://spring.io/projects/spring-cloud-stream" target="_blank" rel="noopener">Spring Cloud Stream</a>分别来实现<code>Producer</code>、<code>Processor</code>以及<code>Consumer</code>模块。最新版的<a href="https://spring.io/projects/spring-cloud-stream" target="_blank" rel="noopener">Spring Cloud Stream</a>彻底拥抱了<code>函数式</code>，使用<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-stream/3.0.6.RELEASE/reference/html/spring-cloud-stream.html#Routing%20with%20functions" target="_blank" rel="noopener">Routing Function</a>替代了早期版本中的<code>@EnableBinding</code>、<code>@StreamEmitter</code>以及<code>@StreamListener</code>等注解，其对应关系为，</p><table><thead><tr><th align="left">Annotation</th><th align="center">Routing Function</th></tr></thead><tbody><tr><td align="left">Source, @StreamEmitter</td><td align="center"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Supplier.html" target="_blank" rel="noopener">java.util.function.Supplier</a></td></tr><tr><td align="left">Sink, @StreamListener</td><td align="center"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Consumer.html" target="_blank" rel="noopener">java.util.function.Consumer</a></td></tr><tr><td align="left">Processor, @EnableBinding(Processor.class)</td><td align="center"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Function.html" target="_blank" rel="noopener">java.util.function.Function</a></td></tr></tbody></table><p>对于<code>Producer</code>，我们只需注册一个类型为<code>Supplier</code>的<code>Bean</code>，而<code>Reactive</code>的<code>Producer</code>，只需要能够一个<code>Supplier&lt;Flux&lt;T&gt;&gt;</code>即可，代码如下，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;ProducerApplication&gt;(*args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">productSource</span><span class="params">()</span></span>: Supplier&lt;Flux&lt;Product&gt;&gt; = Supplier &#123;</span><br><span class="line">        Flux.interval(Duration.ofSeconds(<span class="number">1</span>)).map &#123;</span><br><span class="line">            Product(</span><br><span class="line">                UUID.randomUUID().toString(),</span><br><span class="line">                RandomStringUtils.randomAlphanumeric(<span class="number">5</span>, <span class="number">10</span>),</span><br><span class="line">                Random.nextDouble(<span class="number">1000.00</span>),</span><br><span class="line">                LocalDateTime.now()</span><br><span class="line">            )</span><br><span class="line">        &#125;.onBackpressureDrop().log()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码会每秒钟产生一个ID为UUID，名字为5～10随机字母，价格为0～1000的随机商品。<br>数据由<code>Supplier</code>产生后，我们需要告知<code>Spring Cloud Stream</code>这些数据的<code>Destination</code>，这个<code>Destination</code>应该指向<code>RabbitMQ</code>中名为<code>products</code>的<code>Exchange</code>，我们只需要在<code>application.properties</code>加入下面配置即可，<code>Spring Cloud Stream</code>会自动创建这个<code>Exchange</code>，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.productSource-out-0.destination</span>=<span class="string">products</span></span><br></pre></td></tr></table></figure><p>这里的<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-stream/3.0.6.RELEASE/reference/html/spring-cloud-stream.html#_bindings" target="_blank" rel="noopener">Binding</a>名称就是<code>Supplier</code>的Bean名称<code>productSource</code>。</p><h4 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h4><p>接下来我们实现<code>Processor</code>，按照上一节的说明，<code>Processor</code>应该是一个<code>Function</code>，入参是<code>Flux&lt;Product&gt;</code>，出参是<code>Flux&lt;ProductExchange&gt;</code>，并完成<code>localPrices</code>的计算，详细代码如下，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessorApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;ProcessorApplication&gt;(*args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">productProcessor</span><span class="params">()</span></span>: Function&lt;Flux&lt;Product&gt;, Flux&lt;ProductExchange&gt;&gt; = Function &#123;</span><br><span class="line">        it.log()</span><br><span class="line">            .map &#123; product -&gt;</span><br><span class="line">                ProductExchange(</span><br><span class="line">                    product,</span><br><span class="line">                    ExchangeRate.values()</span><br><span class="line">                        .map &#123; exchange -&gt; exchange.name to exchange.rate * product.price &#125;</span><br><span class="line">                        .toMap()</span><br><span class="line">                )</span><br><span class="line">            &#125;.log()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Processor</code>对应<code>Input</code>与<code>Output</code>两个<code>Binding</code>，所以配置中需要配置两个<code>destination</code>，<code>Input</code>来自于<code>products</code>，<code>Output</code>指向<code>product_exchanges</code>，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.productProcessor-in-0.destination</span>=<span class="string">products</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.productProcessor-in-0.group</span>=<span class="string">product_processor</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.productProcessor-out-0.destination</span>=<span class="string">product_exchanges</span></span><br></pre></td></tr></table></figure><p><code>Input</code>的<code>Binding</code>需要额外配置<code>group</code>的名称，这样可以有多个<code>Consumer</code>同时消费<code>Exchange</code>中的数据来提高并行处理能力。</p><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>接下来我们实现<code>Consumer</code>，按照最新的<code>Spring Cloud Stream</code>规范，<code>Consumer</code>应该对应一个<code>java.util.function.Consumer</code>实现。这里有一点需要注意，由于我们采用的是<code>Reactive</code>形式，而<code>Reactive</code>有自己的<code>Void</code>类型，而不是<code>Java</code>的<code>void</code>关键字，所以这里的<code>Consumer&lt;Flux&lt;T&gt;&gt;</code>应该使用<code>Function&lt;Flux&lt;?&gt;, Mono&lt;Void&gt;&gt;</code>代替，相反的，如果是非<code>Reactive</code>模式下，还是应该正常使用<code>java.util.function.Consumer</code>作为函数类型。</p><p>另外，<code>Consumer</code>在过滤掉低价格的<code>ProductExchange</code>后，还需要将消息转发至<code>Redis</code>中的<code>Pub-Sub Topic</code>中，这里我们还需要配置一个<code>JSON</code>的序列化/反序列化器，这样Pub到<code>Redis</code>中的消息会以<code>JSON</code>数据格式表示，而不是默认的普通<code>String</code> ，这里的<code>ObjectMapper</code>将使用在<code>Core</code>模块里定义好的<code>ObjectMapperExtension</code>，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;ConsumerApplication&gt;(*args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">productExchangeConsumer</span><span class="params">(operations: <span class="type">ReactiveRedisOperations</span>&lt;<span class="type">String</span>, ProductExchange&gt;)</span></span></span><br><span class="line">            : Function&lt;Flux&lt;ProductExchange&gt;, Mono&lt;<span class="built_in">Void</span>&gt;&gt; =</span><br><span class="line">        Function &#123;</span><br><span class="line">            it.filter &#123; pe -&gt; pe.product.price &gt; <span class="number">500.00</span> &#125;</span><br><span class="line">                .log()</span><br><span class="line">                .flatMap &#123; pe -&gt; operations.convertAndSend(PRODUCT_EXCHANGE_TOPIC, pe) &#125;</span><br><span class="line">                .then()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">productExchangeReactiveRedisOperations</span><span class="params">(factory: <span class="type">ReactiveRedisConnectionFactory</span>)</span></span></span><br><span class="line">            : ReactiveRedisOperations&lt;String, ProductExchange&gt; =</span><br><span class="line"></span><br><span class="line">        Jackson2JsonRedisSerializer(ProductExchange::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>).<span class="title">also</span> </span>&#123;</span><br><span class="line">            it.setObjectMapper(ObjectMapperExtension.instance)</span><br><span class="line">        &#125;.let &#123;</span><br><span class="line">            RedisSerializationContext.newSerializationContext&lt;String, ProductExchange&gt;(StringRedisSerializer())</span><br><span class="line">                .value(it).build()</span><br><span class="line">        &#125;.let &#123; ReactiveRedisTemplate&lt;String, ProductExchange&gt;(factory, it) &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，我们定义了两个<code>@Bean</code>，一个是作为<code>Consumer</code>用来处理数据的<code>Function</code>，另外一个就是用来发布消息的<code>ReactiveRedisTemplate</code>，并且配置了<code>JSON</code>的序列化/反序列化器。<br>当然，我们也需要配置一下<code>Consumer</code>的<code>destination</code>和<code>group</code>，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.stream.bindings.productExchangeConsumer-in-0.destination</span>=<span class="string">product_exchanges</span></span><br><span class="line"><span class="meta">spring.cloud.stream.bindings.productExchangeConsumer-in-0.group</span>=<span class="string">product_exchanges_consumer</span></span><br></pre></td></tr></table></figure><h4 id="Notifier"><a href="#Notifier" class="headerlink" title="Notifier"></a>Notifier</h4><p>最后是<code>Notifier</code>。<code>Notifier</code>本身不需要<code>Spring Cloud Stream</code>的支持，只需要订阅<code>Redis</code>中的<code>Pub-Sub Topic</code>，与<code>Consumer</code>，用于监听<code>Redis</code>的<a href="https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/listener/ReactiveRedisMessageListenerContainer.html" target="_blank" rel="noopener">ReactiveRedisMessageListenerContainer</a>也需要自定义一个<code>JSON</code>的序列化/反序列化器，我们把这部分逻辑封装在<code>NotifyService</code>中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotifyService</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> container: ReactiveRedisMessageListenerContainer) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> processor = ReplayProcessor.create&lt;ProductExchange&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> =</span><br><span class="line">        processor.sink().let &#123; sink -&gt;</span><br><span class="line">            container.receive(</span><br><span class="line">                listOf(ChannelTopic.of(PRODUCT_EXCHANGE_TOPIC)),</span><br><span class="line">                RedisSerializationContext.SerializationPair.fromSerializer(StringRedisSerializer()),</span><br><span class="line">                RedisSerializationContext.SerializationPair.fromSerializer(</span><br><span class="line">                    Jackson2JsonRedisSerializer(ProductExchange::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>).<span class="title">also</span> </span>&#123;</span><br><span class="line">                        it.setObjectMapper(ObjectMapperExtension.instance)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">                .map &#123; m -&gt; m.message &#125;</span><br><span class="line">                .doOnNext &#123; sink.next(it) &#125;</span><br><span class="line">                .log()</span><br><span class="line">                .subscribe(&#123;&#125;, &#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">notifyEvents</span><span class="params">(currency: <span class="type">String</span>)</span></span>: Flux&lt;ServerSentEvent&lt;ProductLocal&gt;&gt; =</span><br><span class="line">        processor.map &#123; p -&gt;</span><br><span class="line">            (<span class="keyword">if</span> (currency.toUpperCase() !<span class="keyword">in</span> p.localPrices.keys) DEFAULT_CURRENCY <span class="keyword">else</span> currency.toUpperCase())</span><br><span class="line">                .let &#123;</span><br><span class="line">                    ProductLocal(</span><br><span class="line">                        p.product.id,</span><br><span class="line">                        p.product.name,</span><br><span class="line">                        p.product.createdTime,</span><br><span class="line">                        BigDecimal(p.localPrices[it] ?: <span class="number">0.0</span>).setScale(<span class="number">4</span>, RoundingMode.HALF_EVEN),</span><br><span class="line">                        it</span><br><span class="line">                    )</span><br><span class="line">                &#125;.let &#123; ServerSentEvent.builder(it).id(it.id).build() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductLocal</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: String,</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> createdTime: LocalDateTime,</span><br><span class="line">    <span class="keyword">val</span> localPrice: BigDecimal,</span><br><span class="line">    <span class="keyword">val</span> localCurrency: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上述代码比较容易理解，<code>init</code>方法用于在容器启动时，完成对<code>Pub-Sub Topic</code>的监听，同时将订阅的数据转发至一个<code>Reactor</code>的<code>Processor</code>中，这个<code>Processor</code>就是之后<code>SSE</code>事件的数据源。另外我们还提供一个<code>notifyEvents</code>方法，用于接收<code>currency</code>参数，将缓存在<code>Processor</code>中的数据加工成<code>ProductLocal</code>，并作为<code>SSE</code>发给客户端。</p><p>接下来我们要向Spring容器注册这个service，以及API的Endpoint。与之前采用的<code>@Configuration</code>方式不同，这里我们尝试使用<a href="https://docs.spring.io/spring-integration/docs/current/reference/html/kotlin-dsl.html" target="_blank" rel="noopener">Spring Kotlin DSL</a>来注册Bean。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotifierApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;NotifierApplication&gt;(*args) &#123;</span><br><span class="line">        addInitializers(</span><br><span class="line">            beans &#123;</span><br><span class="line">                bean&lt;ReactiveRedisMessageListenerContainer&gt;()</span><br><span class="line">                bean&lt;NotifyService&gt;()</span><br><span class="line">                bean &#123;</span><br><span class="line">                    ref&lt;NotifyService&gt;().let &#123; notifyService -&gt;</span><br><span class="line">                        router &#123;</span><br><span class="line">                            GET(<span class="string">"/pl/&#123;currency&#125;"</span>) &#123;</span><br><span class="line">                                ServerResponse.ok().body(</span><br><span class="line">                                    BodyInserters.fromServerSentEvents(</span><br><span class="line">                                        notifyService.notifyEvents(</span><br><span class="line">                                            it.pathVariable(<span class="string">"currency"</span>)</span><br><span class="line">                                        )</span><br><span class="line">                                    )</span><br><span class="line">                                )</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码初看比较奇特，其中的<code>beans</code>、<code>bean</code>、<code>router</code>都属于基于<a href="https://kotlinlang.org/docs/reference/type-safe-builders.html" target="_blank" rel="noopener">Kotlin Type-Safe Builders</a>的<code>DSL</code>。这里我们不展开说明，只需要了解<code>Spring Kotlin DSL</code>提供了一种更为简单直接的配置方式。至此，所有模块都实现完毕。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>下面我们开始运行代码。</p><blockquote><p>在运行之前，保证本地已经运行了<code>RabbitMQ</code>和<code>Redis</code>。</p><footer><strong>注意</strong></footer></blockquote><p>首先是<code>Producer</code>，从console中我们可以看到<code>Product</code>数据源源不断产生并虽送到了MQ，</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2020-10-05 14:32:38.518  INFO 5925 --- [oundedElastic-1] o.s.a.r.c.CachingConnectionFactory       : Created new connection: rabbitConnectionFactory.publisher#42e0654e:0/SimpleConnection@75a0a52e [delegate=amqp://guest@127.0.0.1:5672/, localPort= 52496]</span><br><span class="line">2020-10-05 14:32:39.273  INFO 5925 --- [     parallel-1] reactor.Flux.OnBackpressureDrop.1        : onNext(Product(id=6c2b236e-40f8-44ff-a1cf-7a94910944ac, name=cv9pATmM, price=395.31181210651545, createdTime=2020-10-05T14:32:39.272939))</span><br><span class="line">2020-10-05 14:32:40.272  INFO 5925 --- [     parallel-1] reactor.Flux.OnBackpressureDrop.1        : onNext(Product(id=8a10bf35-5e37-4e74-96da-7c8471e56937, name=8Qoagte, price=765.5943349019311, createdTime=2020-10-05T14:32:40.272813))</span><br><span class="line">2020-10-05 14:32:41.272  INFO 5925 --- [     parallel-1] reactor.Flux.OnBackpressureDrop.1        : onNext(Product(id=03751003-daa9-4f19-be69-5ac434b70b7f, name=FihxILXp9, price=351.88328720033377, createdTime=2020-10-05T14:32:41.272239))</span><br><span class="line">2020-10-05 14:32:42.268  INFO 5925 --- [     parallel-1] reactor.Flux.OnBackpressureDrop.1        : onNext(Product(id=d7788f46-009a-4a95-ae06-df88ca133d87, name=6DmSTJE, price=504.01347237601976, createdTime=2020-10-05T14:32:42.268429))</span><br><span class="line">2020-10-05 14:32:43.267  INFO 5925 --- [     parallel-1] reactor.Flux.OnBackpressureDrop.1        : onNext(Product(id=26a06bf0-91a7-4d2f-b15a-f666e072716b, name=J7G766jO0, price=597.8645160007096, createdTime=2020-10-05T14:32:43.267724))</span><br><span class="line">2020-10-05 14:32:44.268  INFO 5925 --- [     parallel-1] reactor.Flux.OnBackpressureDrop.1        : onNext(Product(id=9c0fd106-e00c-44b5-8187-2566737395bb, name=kyWUhn3J, price=152.01109964002336, createdTime=2020-10-05T14:32:44.268194))</span><br><span class="line">2020-10-05 14:32:45.268  INFO 5925 --- [     parallel-1] reactor.Flux.OnBackpressureDrop.1        : onNext(Product(id=110c91ae-41b2-4223-bf33-3759c4f4dc52, name=vlULf6xJ8, price=506.1068481643988, createdTime=2020-10-05T14:32:45.268531))</span><br><span class="line">2020-10-05 14:32:46.270  INFO 5925 --- [     parallel-1] reactor.Flux.OnBackpressureDrop.1        : onNext(Product(id=45c84ed6-7208-4e19-9ead-e9b778512a77, name=8kzXJ, price=15.856892691681669, createdTime=2020-10-05T14:32:46.270622))</span><br><span class="line">2020-10-05 14:32:47.270  INFO 5925 --- [     parallel-1] reactor.Flux.OnBackpressureDrop.1        : onNext(Product(id=569b85c0-7bdd-45ae-a83a-db237779d90f, name=pAZswdD, price=205.12230260372854, createdTime=2020-10-05T14:32:47.270448))</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>接下来是<code>Processor</code>，从console中我们可以看到<code>Product</code>被处理，<code>ProductExchange</code>数据不断产生，</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2020-10-05 14:32:38.772  INFO 5898 --- [uct_processor-1] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: [localhost:5672]</span><br><span class="line">2020-10-05 14:32:38.778  INFO 5898 --- [uct_processor-1] o.s.a.r.c.CachingConnectionFactory       : Created new connection: rabbitConnectionFactory.publisher#a62b940:0/SimpleConnection@c4b6d1e [delegate=amqp://guest@127.0.0.1:5672/, localPort= 52498]</span><br><span class="line">2020-10-05 14:32:39.276  INFO 5898 --- [uct_processor-1] reactor.Flux.Map.1                       : onNext(Product(id=6c2b236e-40f8-44ff-a1cf-7a94910944ac, name=cv9pATmM, price=395.31181210651545, createdTime=2020-10-05T14:32:39.272939))</span><br><span class="line">2020-10-05 14:32:39.276  INFO 5898 --- [uct_processor-1] reactor.Flux.Map.2                       : onNext(ProductExchange(product=Product(id=6c2b236e-40f8-44ff-a1cf-7a94910944ac, name=cv9pATmM, price=395.31181210651545, createdTime=2020-10-05T14:32:39.272939), localPrices=&#123;USD=395.31181210651545, CNY=2684.404391290504, JPY=41636.0584853939, EUR=337.39863163291096, GBP=305.57603075833646&#125;))</span><br><span class="line">2020-10-05 14:32:40.277  INFO 5898 --- [uct_processor-1] reactor.Flux.Map.1                       : onNext(Product(id=8a10bf35-5e37-4e74-96da-7c8471e56937, name=8Qoagte, price=765.5943349019311, createdTime=2020-10-05T14:32:40.272813))</span><br><span class="line">2020-10-05 14:32:40.277  INFO 5898 --- [uct_processor-1] reactor.Flux.Map.2                       : onNext(ProductExchange(product=Product(id=8a10bf35-5e37-4e74-96da-7c8471e56937, name=8Qoagte, price=765.5943349019311, createdTime=2020-10-05T14:32:40.272813), localPrices=&#123;USD=765.5943349019311, CNY=5198.844890585054, JPY=80635.91708581193, EUR=653.4347648387983, GBP=591.8044208791928&#125;))</span><br><span class="line">2020-10-05 14:32:41.276  INFO 5898 --- [uct_processor-1] reactor.Flux.Map.1                       : onNext(Product(id=03751003-daa9-4f19-be69-5ac434b70b7f, name=FihxILXp9, price=351.88328720033377, createdTime=2020-10-05T14:32:41.272239))</span><br><span class="line">2020-10-05 14:32:41.276  INFO 5898 --- [uct_processor-1] reactor.Flux.Map.2                       : onNext(ProductExchange(product=Product(id=03751003-daa9-4f19-be69-5ac434b70b7f, name=FihxILXp9, price=351.88328720033377, createdTime=2020-10-05T14:32:41.272239), localPrices=&#123;USD=351.88328720033377, CNY=2389.4986500625864, JPY=37061.966471060274, EUR=300.3323856254849, GBP=272.005781005858&#125;))</span><br><span class="line">2020-10-05 14:32:42.277  INFO 5898 --- [uct_processor-1] reactor.Flux.Map.1                       : onNext(Product(id=d7788f46-009a-4a95-ae06-df88ca133d87, name=6DmSTJE, price=504.01347237601976, createdTime=2020-10-05T14:32:42.268429))</span><br><span class="line">2020-10-05 14:32:42.277  INFO 5898 --- [uct_processor-1] reactor.Flux.Map.2                       : onNext(ProductExchange(product=Product(id=d7788f46-009a-4a95-ae06-df88ca133d87, name=6DmSTJE, price=504.01347237601976, createdTime=2020-10-05T14:32:42.268429), localPrices=&#123;USD=504.01347237601976, CNY=3422.5538855166, JPY=53085.01737261533, EUR=430.17549867293286, GBP=389.6024141466633&#125;))</span><br><span class="line">2020-10-05 14:32:43.270  INFO 5898 --- [uct_processor-1] reactor.Flux.Map.1                       : onNext(Product(id=26a06bf0-91a7-4d2f-b15a-f666e072716b, name=J7G766jO0, price=597.8645160007096, createdTime=2020-10-05T14:32:43.267724))</span><br><span class="line">2020-10-05 14:32:43.270  INFO 5898 --- [uct_processor-1] reactor.Flux.Map.2                       : onNext(ProductExchange(product=Product(id=26a06bf0-91a7-4d2f-b15a-f666e072716b, name=J7G766jO0, price=597.8645160007096, createdTime=2020-10-05T14:32:43.267724), localPrices=&#123;USD=597.8645160007096, CNY=4059.858782354419, JPY=62969.84100196834, EUR=510.27736440660567, GBP=462.14927086854857&#125;))</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>然后是<code>Consumer</code>，我们可以直接通过<code>redis-cli</code>来订阅<code>Redis</code>的<code>Pub-Sub Topic</code>，</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe topic:pe</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) "subscribe"</span><br><span class="line">2) "topic:pe"</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) "message"</span><br><span class="line">2) "topic:pe"</span><br><span class="line">3) "&#123;\"product\":&#123;\"id\":\"3e155fa7-9f42-4685-aeba-534342bc2f05\",\"name\":\"tvnzfHSJh\",\"price\":908.6521294566128,\"createdTime\":\"2020-10-05T14:36:03.278801\"&#125;,\"localPrices\":&#123;\"USD\":908.6521294566128,\"CNY\":6170.293150288076,\"JPY\":95703.42207416597,\"EUR\":775.5345924912191,\"GBP\":702.3880960699616&#125;&#125;"</span><br><span class="line">1) "message"</span><br><span class="line">2) "topic:pe"</span><br><span class="line">3) "&#123;\"product\":&#123;\"id\":\"563638ee-deef-4102-92f8-f8a95dbcea71\",\"name\":\"4n93HpIDy\",\"price\":730.6959805104445,\"createdTime\":\"2020-10-05T14:36:06.273764\"&#125;,\"localPrices\":&#123;\"USD\":730.6959805104445,\"CNY\":4961.864125254225,\"JPY\":76960.26186887037,\"EUR\":623.6490193656645,\"GBP\":564.8279929345737&#125;&#125;"</span><br><span class="line">1) "message"</span><br><span class="line">2) "topic:pe"</span><br><span class="line">3) "&#123;\"product\":&#123;\"id\":\"f578f6ef-2858-4f2c-8ddb-53aff31e7b60\",\"name\":\"tBJPIJg\",\"price\":997.1833424008273,\"createdTime\":\"2020-10-05T14:36:07.274668\"&#125;,\"localPrices\":&#123;\"USD\":997.1833424008273,\"CNY\":6771.473204907058,\"JPY\":105027.93666503018,\"EUR\":851.0959827391061,\"GBP\":770.8227236758395&#125;&#125;"</span><br><span class="line">1) "message"</span><br><span class="line">2) "topic:pe"</span><br><span class="line">3) "&#123;\"product\":&#123;\"id\":\"8825530f-4c92-4989-80a7-11344752eb95\",\"name\":\"ffAND\",\"price\":656.5872951974707,\"createdTime\":\"2020-10-05T14:36:08.278398\"&#125;,\"localPrices\":&#123;\"USD\":656.5872951974707,\"CNY\":4458.621686767945,\"JPY\":69154.79423175553,\"EUR\":560.3972564510412,\"GBP\":507.5419791876448&#125;&#125;"</span><br><span class="line">1) "message"</span><br><span class="line">2) "topic:pe"</span><br><span class="line">3) "&#123;\"product\":&#123;\"id\":\"bed9f33f-2c00-4e6f-a73a-27c2d4472a25\",\"name\":\"t1eCrzm\",\"price\":569.2236131405484,\"createdTime\":\"2020-10-05T14:36:09.276028\"&#125;,\"localPrices\":&#123;\"USD\":569.2236131405484,\"CNY\":3865.3698673922086,\"JPY\":59953.24936458301,\"EUR\":485.8323538154581,\"GBP\":440.00985295764394&#125;&#125;"</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>最后是<code>Notifier</code>，我们可以直接使用<code>curl</code>命令来调用API，</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/pl/jpy</span><br><span class="line">id:8a10bf35-5e37-4e74-96da-7c8471e56937</span><br><span class="line">data:&#123;"id":"8a10bf35-5e37-4e74-96da-7c8471e56937","name":"8Qoagte","createdTime":"2020-10-05T14:32:40.272813","localPrice":80635.9171,"localCurrency":"JPY"&#125;</span><br><span class="line"></span><br><span class="line">id:d7788f46-009a-4a95-ae06-df88ca133d87</span><br><span class="line">data:&#123;"id":"d7788f46-009a-4a95-ae06-df88ca133d87","name":"6DmSTJE","createdTime":"2020-10-05T14:32:42.268429","localPrice":53085.0174,"localCurrency":"JPY"&#125;</span><br><span class="line"></span><br><span class="line">id:26a06bf0-91a7-4d2f-b15a-f666e072716b</span><br><span class="line">data:&#123;"id":"26a06bf0-91a7-4d2f-b15a-f666e072716b","name":"J7G766jO0","createdTime":"2020-10-05T14:32:43.267724","localPrice":62969.8410,"localCurrency":"JPY"&#125;</span><br><span class="line"></span><br><span class="line">id:110c91ae-41b2-4223-bf33-3759c4f4dc52</span><br><span class="line">data:&#123;"id":"110c91ae-41b2-4223-bf33-3759c4f4dc52","name":"vlULf6xJ8","createdTime":"2020-10-05T14:32:45.268531","localPrice":53305.5013,"localCurrency":"JPY"&#125;</span><br><span class="line"></span><br><span class="line">id:fb014f7e-3709-4223-85a2-6b4b6b6927b3</span><br><span class="line">data:&#123;"id":"fb014f7e-3709-4223-85a2-6b4b6b6927b3","name":"LpoMwa","createdTime":"2020-10-05T14:32:48.271629","localPrice":75403.9377,"localCurrency":"JPY"&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文只是做了一个<code>Spring</code> + <code>Kotlin</code>的初步整合应用，并少量涉及了<code>Spring</code>针对<code>Kotlin</code>所做的一些定制和优化。从这些简单的示例中，我们仍然能够感受到<code>Kotlin</code>语言的强大表现力和独特的魅力。即使不去使用<code>DSL</code>等稍微高级的特性，<code>Kotlin</code>仍然表现的足够简洁与高效。<code>Spring</code>与<code>Kotlin</code>的初次相见就已擦出火花，相信在未来，<code>Spring</code>与<code>Kotlin</code>还会迸射出更加绮丽的色彩。</p><p>本文的源代码已放置在<a href="https://github.com/dipengfei/reactive-messaging-kt" target="_blank" rel="noopener">Github</a>，欢迎大家一起讨论。谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一门新兴的现代化编程语言，&lt;a href=&quot;https://kotlinlang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin&lt;/a&gt;正获得广泛的关注，&lt;a href=&quot;https://spring.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring&lt;/a&gt;社区也将支持&lt;code&gt;Kotlin&lt;/code&gt;语言作为下一阶段的&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/08/the-state-of-kotlin-support-in-spring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;重要工作&lt;/a&gt;，甚至抛出了&lt;a href=&quot;https://speakerdeck.com/sdeleuze/why-spring-loves-kotlin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Loves Kotin&lt;/a&gt;和&lt;a href=&quot;https://kotlin.link/articles/Spring-Boot-and-Kotlin-a-match-made-in-Heaven.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Match Made in Heaven&lt;/a&gt;这般暧昧的论调。本文暂不去讨论&lt;code&gt;Kotlin&lt;/code&gt;语言的细节，而是通过使用&lt;code&gt;Kotlin&lt;/code&gt;和&lt;a href=&quot;https://spring.io/projects/spring-cloud-stream&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Cloud Stream&lt;/a&gt;构建实时消息系统来领略一番&lt;code&gt;Spring Loves Kotlin&lt;/code&gt;的魅力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实践" scheme="https://danielpf.me/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="reactive" scheme="https://danielpf.me/tags/reactive/"/>
    
      <category term="kotlin" scheme="https://danielpf.me/tags/kotlin/"/>
    
      <category term="spring" scheme="https://danielpf.me/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>小论Spring中@Bean的Lite Mode</title>
    <link href="https://danielpf.me/2020/08/29/spring-bean-lite-mode/"/>
    <id>https://danielpf.me/2020/08/29/spring-bean-lite-mode/</id>
    <published>2020-08-29T14:19:22.000Z</published>
    <updated>2020-08-29T17:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html" target="_blank" rel="noopener">@Bean</a>注解在现代化Spring应用中得到了广泛的应用，在大多数场景下，<code>@Bean</code>是配合<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html" target="_blank" rel="noopener">@Configuration</a>注解一起使用的，但这并不意味着<code>@Bean</code>必须配合<code>@Configuration</code>使用，反之，它可以与<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html" target="_blank" rel="noopener">@Service</a>、<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Component.html" target="_blank" rel="noopener">@Component</a>等Bean声明注解一起使用，这种用法与配合<code>@Configuration</code>使用有什么区别呢？什么是<code>@Bean</code>的<code>Lite Mode</code>呢？本文将给出答案。</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>当<code>@Bean</code>定义在<code>@Component</code>等Bean声明注解内或<code>POJO</code>对象内部时称之为<code>Lite Mode</code>，反之，定义在<code>@Configuration</code>对象内部时称之为<code>Full Mode</code>。</p><footer><strong>Lite Mode定义</strong></footer></blockquote><p>以上定义概括于<code>@Bean</code>的<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html" target="_blank" rel="noopener">API</a>文档以及Spring Framework的<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java" target="_blank" rel="noopener">官方文档</a>，为方便大家理解，下面我们通过一个例子来详细说明。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>这里展示一个非常典型<code>Lite Mode</code>场景，并包含<code>内部Bean依赖(inter-bean dependencies)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> AtomicLong COUNTER = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">        LiteService() &#123;</span><br><span class="line">            log.info(<span class="string">"creating..."</span>);</span><br><span class="line">            COUNTER.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"initializing..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"doing..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">LiteService <span class="title">liteService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LiteService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">withDependency</span><span class="params">(LiteService liteService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"running with dependency"</span>);</span><br><span class="line">            liteService.doSomething();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">withInterReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"running with InterReference"</span>);</span><br><span class="line">            <span class="keyword">this</span>.liteService().doSomething();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">showCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; log.info(<span class="string">"total instance count: &#123;&#125;"</span>, </span><br><span class="line">                                LiteService.COUNTER.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简要解释一下，</p><ul><li>定义了一个<code>LiteConfig</code>类，但注解为<code>Service</code>，按照定义，其内部定义的<code>@Bean</code>的行为都会处在<code>Lite Mode</code>下；</li><li><code>LiteService</code>是一个简单的类，包含了一个构造方法，一个初始化方法(<code>init</code>)，一个具体执行业务逻辑的方法(<code>doSomething</code>)，除日志输出外，构造方法会记录创建实例的个数；</li><li>通过<code>@Bean</code>创建一个<code>LiteService</code>的Bean；</li><li><code>LiteService</code>Bean会被接下来的两个<code>CommandLineRunner</code>Bean依赖，依赖的方式不同，<code>withDependency</code>通过方法参数得到依赖，而<code>withInterReference</code>通过内部方法调用得到依赖；</li><li>最后一个<code>showCounter</code>用于打印在以上代码执行后，总共创建的<code>LiteService</code>实例的个数。</li></ul><p>让我们执行这段代码并查看输出，这里将略去不相关部分，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Root WebApplicationContext: initialization completed in 1290 ms</span><br><span class="line">creating...</span><br><span class="line">initializing...</span><br><span class="line">running with dependency</span><br><span class="line">doing...</span><br><span class="line">running with InterReference</span><br><span class="line">creating...</span><br><span class="line">doing...</span><br><span class="line">total instance count: 2</span><br></pre></td></tr></table></figure><p>从运行结果上，我们不难看出，</p><ol><li>Spring容器初始化完成之后，<code>liteService()</code>方法被Spring执行，创建了一个<code>LiteService</code>的Bean，并回调了<code>init</code>方法；</li><li>接下来<code>withDependency</code>的<code>CommandLineRunner</code>运行，<code>liteService</code>作为依赖被传入，并调用了<code>doSomething</code>方法；</li><li>接下来<code>withInterReference</code>的<code>CommandLineRunner</code>运行，通过调用<code>liteService()</code>方法来获取依赖，这时<code>liteService()</code>方法本体<strong>又被执行了一遍</strong>，并且<strong>没有回调<code>init</code>方法</strong>；</li><li>接下来<code>showCounter</code>的<code>CommandLineRunner</code>运行，打印了<code>LiteService</code>实例的总数，共<strong>2</strong>个。</li></ol><p>具体原因，我们稍后解释，这里我们先吧<code>@Service</code>注解换成<code>@Configuration</code>，看会发生什么，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Root WebApplicationContext: initialization completed in 553 ms</span><br><span class="line">creating...</span><br><span class="line">initializing...</span><br><span class="line">running with dependency</span><br><span class="line">doing...</span><br><span class="line">running with InterReference</span><br><span class="line">doing...</span><br><span class="line">total instance count: 1</span><br></pre></td></tr></table></figure><p>比较之前的运行结果，我们发现，</p><ol><li>与之前<strong>相同</strong>：Spring容器初始化完成之后，<code>liteService()</code>方法被Spring执行，创建了一个<code>LiteService</code>的Bean，并回调了<code>init</code>方法；</li><li>与之前<strong>相同</strong>：接下来<code>withDependency</code>的<code>CommandLineRunner</code>运行，<code>liteService</code>作为依赖被传入，并调用了<code>doSomething</code>方法；</li><li>与之前<strong>不同</strong>：接下来<code>withInterReference</code>的<code>CommandLineRunner</code>运行，通过调用<code>liteService()</code>方法来获取依赖，<strong>没有</strong>重新执行本体，<strong>直接调用了<code>doSomething</code>方法</strong>；</li><li>与之前<strong>不同</strong>：接下来<code>showCounter</code>的<code>CommandLineRunner</code>运行，打印了<code>LiteService</code>实例的总数，只有<strong>1</strong>个。</li></ol><p>综上所述，两次运行结果的差异表现在当使用<code>inter-bean references</code>获取内部依赖时的行为不同，<code>Lite Mode</code>下，内部方法调用就是纯粹的执行了内部方法的逻辑，而在<code>Full Mode</code>下，内部方法调用被Spring拦截且直接返回了已经创建好的Bean，并没有重新执行内部方法的逻辑。</p><h3 id="揭秘"><a href="#揭秘" class="headerlink" title="揭秘"></a>揭秘</h3><p>官方文档有大段的论述来解释<code>Lite Mode</code>与<code>Full Mode</code>，原文稍微有一些晦涩，这里我提炼一下官方文档中关于<code>Lite Mode</code>与<code>Full Mode</code>的异同，</p><p><strong>相同点：</strong></p><ul><li><code>Lite Mode</code>定义下的Bean本质上与<code>Full Mode</code>定义下的Bean没有本质区别，都可以被其他Bean依赖；</li><li><code>Bean容器</code>仍然会管理<code>Lite Mode</code>定义下的Bean的生命周期，<code>@PostConstruct</code>、<code>@PreDestroy</code>等注解依然生效；</li></ul><p><strong>不同点：</strong></p><ul><li><code>Lite Mode</code>无法兼容<code>内部Bean依赖(inter-bean dependencies)</code>，究其本质，在<code>Full Mode</code>下，Spring会使用类似<code>CGLIB proxy</code>来拦截所有的方法调用，如果发现内部方法调用是为了获取<code>内部Bean依赖(inter-bean dependencies)</code>，那么Spring将直接返回这个Bean。</li></ul><p>从这些异同点我们可以看出，Spring的设计者对于<strong>使用类似<code>CGLIB proxy</code>来拦截所有的方法</strong>这类操作还是比较慎重的，所以不惜用<code>Full Mode</code>和<code>Lite Mode</code>加以区分，也为使用者提供了精确控制与选择的机会，即使绝大部分使用者一般都会选择使用<code>Full Mode</code>。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>有同学可能会问，如上面的例子所示，<code>withDependency</code>的<code>CommandLineRunner</code>是通过方法参数来获取依赖的，只不过这个依赖是在同一个类里面由另外一个<code>@Bean</code>方法定义的<code>内部Bean依赖</code>，这个也是Spring推荐的方式，那么不就可以避免通过内部方法调用来获取依赖了吗？</p><p>一般情况下，答案是肯定的，但也有例外情况，假设我们不能自定义一个使用依赖的方法的参数呢？这种场景存在吗？<br>看下面的例子，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DummyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"initializing dummy interceptor..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//handling logic</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DummyInterceptor <span class="title">dummyInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DummyInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">this</span>.dummyInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Spring Boot</code>应用中，我们经常会通过扩展<code>WebMvcConfigurationSupport</code>来自定义一些MVC相关的设置，上面的例子就是在自定义拦截器，而拦截器恰好是在当前类里面通过<code>@Bean</code>创建的一个Bean，而<code>addInterceptors</code>方法却是要覆写父类的，无法通过修改参数列表来获取依赖，只能通过调用内部方法来获取，这时<code>Full Mode</code>就有用武之地了，通过调用内部方法，就会得到一个完整的Spring容器管理的拦截器Bean。这样的场景在扩展Spring的各种Config里很常见，例如<code>Spring Security</code>、<code>Spring Data Couchbase</code>等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Spring体系中，<code>@Bean</code>是一个再常用不过的注解，但<code>Lite Mode</code>与<code>Full Mode</code>并不被人所熟知。当我们肆意使用<code>@Bean</code>定义着Bean，通过方法参数传递传递着依赖时，我们并不清楚Spring的设计者有多少设计上的考量以及Spring的开发者通过哪些手段和技巧实现了设计者的理念。表面上看，这些无伤大雅，也无关紧要，甚至作为细节，使用者也无需关心，我随便baidu了一下<code>spring @bean lite mode</code>这几个关键字，发现为数不多的文章里，大部分是机器翻译了Spring的官方文档，幸甚幸甚，至少还有人去看这部分的文档。</p><p>分享这个小技巧，并不是为了炫技，因为这本身也没有什么高深的，我甚至都没有贴一行Spring的源代码，我也不想去找，因为我觉得Spring官方文档上的论述就已经足够好了，不管我们是否关心，它都在那里。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>前面提到，<code>Lite Mode</code>是可以用在<code>POJO</code>对象里的，那会是怎样的行为呢？有兴趣的朋友可以自己试试看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@Bean&lt;/a&gt;注解在现代化Spring应用中得到了广泛的应用，在大多数场景下，&lt;code&gt;@Bean&lt;/code&gt;是配合&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@Configuration&lt;/a&gt;注解一起使用的，但这并不意味着&lt;code&gt;@Bean&lt;/code&gt;必须配合&lt;code&gt;@Configuration&lt;/code&gt;使用，反之，它可以与&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@Service&lt;/a&gt;、&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@Component&lt;/a&gt;等Bean声明注解一起使用，这种用法与配合&lt;code&gt;@Configuration&lt;/code&gt;使用有什么区别呢？什么是&lt;code&gt;@Bean&lt;/code&gt;的&lt;code&gt;Lite Mode&lt;/code&gt;呢？本文将给出答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="https://danielpf.me/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="spring" scheme="https://danielpf.me/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>再论Spring依赖注入</title>
    <link href="https://danielpf.me/2020/06/12/spring-dependency-injection-rethinking/"/>
    <id>https://danielpf.me/2020/06/12/spring-dependency-injection-rethinking/</id>
    <published>2020-06-12T13:11:31.000Z</published>
    <updated>2020-06-13T05:48:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>依赖注入(Dependency Injection)</code>是<a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">Spring Framework</a>最核心的概念之一，通常来说，<code>依赖注入</code>主要分成<code>构造注入(Constructor-based Dependency Injection)</code>与<code>setter注入(Setter-based Dependency Injection)</code>两种类型，本文会结合<code>Spring Framkework</code>的发展以及项目中的具体应用，在<code>封装性(Encapsulation)</code>、<code>不可变性(Immutability)</code>、<code>安全性(Security)</code>以及<code>循环依赖性(Circular Dependencies)</code>等方面来重新探讨这两种依赖注入方式，进而总结出在“新时代”的背景下，如何适当地选择。</p><a id="more"></a><blockquote><p>谨以此文献给在code review中备受打击的小G同学。。。</p><footer><strong>篇首语</strong></footer></blockquote><h3 id="细说分类"><a href="#细说分类" class="headerlink" title="细说分类"></a>细说分类</h3><p>首先说<code>setter注入</code>，这是最常见也是最老牌的一种依赖注入方式，套用<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-setter-injection" target="_blank" rel="noopener">Spring官方文档</a>的例子，这种注入方式的特点是先<code>创建实例</code>，再<code>反射调用setter方法</code>注入依赖，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>@Autowired</code>注解的帮助下，<code>setter注入</code>也衍生出了最简化的形式，以上代码直接可以写作下面的形式，我们姑且叫它<code>私有变量注入</code>，这种注入方式的特点是，先<code>创建实例</code>，再<code>反射修改私有变量</code>注入依赖，时至今日，相信很多coder还是非常乐于使用这种依赖注入方式，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来再说<code>构造注入</code>，这种注入方式更加直接，其特点是,<code>创建实例</code>与<code>注入依赖</code>同时进行，都是通过<code>反射调用构造方法</code>完成，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再介绍一种进阶版，采用<code>lombok</code> + <code>private finaal</code>的构造注入才是最常见的写法，我们接下来讨论的<code>构造注入</code>，如不特殊说明，都是指的这种方式，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lombok will help generate this method during compiling time</span></span><br><span class="line">    <span class="comment">//public SimpleMovieLister(MovieFinder movieFinder) &#123;</span></span><br><span class="line">        <span class="comment">//this.movieFinder = movieFinder;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java" target="_blank" rel="noopener">Java-based Container Configuration</a>越来越流行，<code>构造注入</code>也有了广义上的版本，我们姑且叫它<code>方法参数注入</code>，与普通<code>构造注入</code>不同的是，依赖是作为<code>反射调用bean创建方法</code>的<code>参数(args)</code>注入，而对象实例化过程，是由在方法内部编程实现，而bean的依赖可能是<code>构造注入</code>，也可能是<code>setter注入</code>，看下面的例子，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieListerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMovieLister <span class="title">simpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// implemented as constructor-based injection</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleMovieLister(movieFinder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// it can be also implemented as setter-based injection</span></span><br><span class="line">        <span class="comment">// SimpleMovieLister lister = new SimpleMovieLister();</span></span><br><span class="line">        <span class="comment">// lister.setMovieFinder(movieFinder);</span></span><br><span class="line">        <span class="comment">// return lister;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊依赖"><a href="#特殊依赖" class="headerlink" title="特殊依赖"></a>特殊依赖</h3><p>这里还需要举例说明两种特殊的依赖。</p><p>第一种很常见，其依赖不是其他的bean，而是一个外部的值，还以上面的代码为例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;app.movie_lister.max_size:100&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer maxSize;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种比较特殊，但有可能在不知不觉中还是接触到了，这个就是<code>循环依赖</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个列子只是最简单的<code>循环依赖</code>，还有更复杂一些的情况，例如ServiceA -&gt; ServiceB -&gt; ServiceC -&gt; ServiceA，这里不再赘述。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>我们用一个表格来对比这些注入方式，</p><table><thead><tr><th align="left">对比项</th><th align="center">setter注入</th><th align="center">私有变量注入</th><th align="center">构造注入(private final)</th></tr></thead><tbody><tr><td align="left">保证封装性？</td><td align="center"><strong>Yes</strong></td><td align="center"><em>No</em></td><td align="center"><strong>Yes</strong></td></tr><tr><td align="left">保证不可变性？</td><td align="center"><em>No</em></td><td align="center"><em>No</em></td><td align="center"><strong>Yes</strong></td></tr><tr><td align="left">保证安全性？</td><td align="center"><em>No</em></td><td align="center"><em>No</em></td><td align="center"><strong>Yes</strong></td></tr><tr><td align="left">允许循环依赖？</td><td align="center"><strong>Yes</strong></td><td align="center"><strong>Yes</strong></td><td align="center"><em>No</em></td></tr></tbody></table><p>下面详细解释一下表格内容。</p><p><a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" target="_blank" rel="noopener">封装性(Encapsulation)</a>是OOP的三大特性之一，这里我们不做展开说明，而<code>setter注入</code>与<code>构造注入</code>为何没有破坏封装性，也非常容易理解，那就是Spring是通过<code>反射私有变量访问器(setter方法或构造方法)</code>来完成依赖注入的，完全遵守了封装性的准则。那么问题来了，为什么<code>私有变量注入</code>破坏了封装性？</p><blockquote><p><code>私有变量注入</code>本质上是通过<code>反射修改私有(private)</code>变量值来完成依赖注入的，完全没有通过<code>私有变量访问器</code>，换句话说，一个<code>私有</code>的变量平白无故地就被修改了值。</p><footer><strong>为什么“私有变量注入”破坏了封装性？</strong></footer></blockquote><p>乍一看，即使封装性被破坏，也没有什么大不了的，从结果上看，未经<code>私有变量访问器</code>修改的值也是符合预期的，但事实上一旦封装性被破坏，<code>不可变性(Immutability)</code>亦不能保证。<a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">不可变性(Immutability)</a>也是软件OOP里一个非常重要设计理念，这里我们仍不做展开。但依照上面的表格所示，即使封装性可以保证，仍不能保证一个对象的不可变性。</p><p>啰嗦了这么多，无论<code>封装性</code>也好，<code>不可变性</code>也罢，其实都是为了保重代码在处理<code>依赖注入</code>时的<code>安全性(Security)</code>。这里的<code>安全性(Security)</code>是一个相对狭义的概念，其含义可以概括为一点，<strong>不可变的依赖，才可能是无害的依赖</strong>。说起来可能很抽象，下面用两个逆向场景具体说明，</p><blockquote><p><code>setter</code>作为访问器，在开放给Spring的同时，也开发给了其他代码。无论善意或恶意，只需要重新调用一下setXXX方法，哪怕传入一个<code>null</code>值，其影响也足够致命。</p><footer><strong>为什么“setter注入”不安全？</strong></footer></blockquote><blockquote><p>与<code>setter注入</code>类似，虽然<code>私有变量注入</code>并没有提供一个<code>setter</code>作为访问器，但通过<code>反射</code>，仍然可以直接修改私有变量的值，在运行时改变依赖。</p><footer><strong>为什么“私有变量注入”不安全？</strong></footer></blockquote><p>以上两个场景概括起来，就是在说明，存在这样或那样的可能性，在<code>运行时(runtime)</code>阶段，依赖是有可能被有意或无意修改，从而导致程序的行为不正确，甚至产生灾难性后果。基于以上分析，也很容易推导出保证运行时安全性的手段，那就是<code>构造注入且私有变量为final</code>,</p><blockquote><p>简而言之，Java语言在<code>语义(semantic)</code>上保证<code>final</code>是不可修改的，所以不会在<code>运行时(runtime)</code>被修改，即使通过<code>反射</code>亦不可能。</p><footer><strong>为什么“private final”安全？</strong></footer></blockquote><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>技术本无对错，只看是否适用于不同的场景，而不同的技术，在不同的历史时期和时代背景下，会进化、发展、演变出不同的方式、流派、体系，Spring Framework亦是如此。</p><p>在Spring 2.5.x时代，<code>依赖注入</code>与<code>控制反转</code>方兴未艾，广大Java EE的开发人员，还在被EJB折腾的七窍生烟之时，Spring所倡导的这些理念，让从业者有久旱逢甘霖之快感，而受限于当时的技术理念与潮流，仍使用XML作为bean相互依赖的组织媒介，使用<code>setter注入</code>便是“多快好省”的不二法门。</p><p>随着时间的推移，人们对<code>依赖注入</code>、<code>控制反转</code>理解和实践的逐渐深入，Spring 3.x也呼之欲出。开发者也越发体会到，bean与bean之间的依赖关系，在绝大多数场景下是<code>内联</code>的，是<code>自然</code>的，甚至是<code>与生俱来</code>的，无论你是否用XML等配置方式去描述它，这些bean之间的依赖关系，都在那里，且相对稳定，几乎不会被修改。于是，在这个理念的指导下，才有了bean的<code>自动装配(Autowired)</code>，才有了后来<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-annotation-config" target="_blank" rel="noopener">Annotation-based Container Configuration</a>，曾经漫山遍野的XML也淹没于扑面而来的<code>@Autowired</code>注解之中，而<code>私有变量注入</code>注入更是让人高潮迭起，如痴如醉，被传统Java EE思想钳制多年的思想也随之解放，以少量的XML加以大量的<code>私有变量注入</code>也蔚然成风，仿佛构造方法和setter都成了明日黄花，不合时宜。</p><p>一个好的技术框架，其生命力往往取决于设计者的思想境界。当劳苦大众们在为使用<code>私有变量注入</code>大幅提高生产力而弹冠相庆时，Spring团队却没有停下审视和思考的脚步。于是更加极至的<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java" target="_blank" rel="noopener">Java-based Container Configuration</a>也随之诞生，并在Spring 5.x后受到Spring官方推崇。有人说<code>Java-based Container</code>是历史的倒退，是Java EE糟粕的复辟，现在看来，不得不佩服Spring设计者独到的眼光和正派的价值观，其终极目标，仍然是以<code>不可变性</code>与<code>安全性</code>在程序设计领域重要的作用为导向的，尤其在以<code>线程模型</code>为程序基本运行模型的JVM语言里更是如此，所以依赖注入方式在经过无数的<code>私有变量注入</code>滥用，在肯定<code>bean之间的自然依赖关系</code>的条件下，回归到了<code>private final变量 + 构造注入</code>的方式，继而出现了使用lombok来简化唯一构造方法的终极写法。</p><p>拥抱变化，拥抱发展，这才是Spring Framework经久不衰的主要原因。而作为终端用户的我们，除了与时俱进，更要尊重技术发展的潮流，既不能用旧时代的想法和思路来处理新时代问题，也不能用新时代的视角和手段来否定旧时代技术，唯有如此，才是技术人员应有的素质和觉悟。</p><p>让我们回归本篇文章的讨论，在新时代的背景下，如何选择依赖注入方式呢？归纳起来，也就是下面几点，</p><ol><li>优先采用<code>private final变量 + 构造注入</code>来注入依赖；</li><li>在没有其他<code>值(依赖)</code>需要注入时，可以考虑用lombok的<code>@RequiredArgsConstructor</code>来简化代码；</li><li>原则上应避免<code>循环依赖</code>，如果实在无法避免，可以适度使用<code>setter注入</code>，但仍应该避免使用<code>私有变量注入</code>；</li><li>在Unit Test等场景下，仍然可以使用<code>私有变量注入</code>来简化代码。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;依赖注入(Dependency Injection)&lt;/code&gt;是&lt;a href=&quot;https://spring.io/projects/spring-framework&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Framework&lt;/a&gt;最核心的概念之一，通常来说，&lt;code&gt;依赖注入&lt;/code&gt;主要分成&lt;code&gt;构造注入(Constructor-based Dependency Injection)&lt;/code&gt;与&lt;code&gt;setter注入(Setter-based Dependency Injection)&lt;/code&gt;两种类型，本文会结合&lt;code&gt;Spring Framkework&lt;/code&gt;的发展以及项目中的具体应用，在&lt;code&gt;封装性(Encapsulation)&lt;/code&gt;、&lt;code&gt;不可变性(Immutability)&lt;/code&gt;、&lt;code&gt;安全性(Security)&lt;/code&gt;以及&lt;code&gt;循环依赖性(Circular Dependencies)&lt;/code&gt;等方面来重新探讨这两种依赖注入方式，进而总结出在“新时代”的背景下，如何适当地选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://danielpf.me/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="spring" scheme="https://danielpf.me/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>茴字的N种写法</title>
    <link href="https://danielpf.me/2020/05/03/n-ways-of-writing-word-hui/"/>
    <id>https://danielpf.me/2020/05/03/n-ways-of-writing-word-hui/</id>
    <published>2020-05-03T13:55:48.000Z</published>
    <updated>2020-05-03T18:00:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://zh.wikipedia.org/wiki/%E9%B2%81%E8%BF%85" target="_blank" rel="noopener">鲁迅</a>的名篇<a href="https://zh.m.wikisource.org/zh-hans/%E5%AD%94%E4%B9%99%E5%B7%B1" target="_blank" rel="noopener">《孔乙己》</a>中，有这样一个桥段，<code>孔乙己</code>问作者是否知道茴香豆的“茴”字，有四种写法，用于讽刺<code>孔乙己</code>这类落魄文人的迂腐。我们在coding时，为实现某一逻辑，也会存在各种各样的方案，而每种方案的背后，除了有各自的特点之外，也或多或少与给出这些方案的人的技能、经历、思考方式有关，本文试图以亲身经历的一个小故事，来探究编程领域内茴字N种写法背后的故事。    </p><a id="more"></a><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>一次代码Review的过程中，看到了类似下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OrderApiResponse <span class="title">getOrder</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> HttpEntity&lt;&gt;(Collections.singletonMap(<span class="string">"orderId"</span>, orderId), headers);</span><br><span class="line">    <span class="keyword">var</span> response = restTemplate.exchange(orderApiUri, HttpMethod.POST, request, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> JSON.parseObject(response.getBody(), OrderApiResponse<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放眼望去，感觉没什么不对；仔细端详，又感觉哪里不对….为什么要用<code>String</code>作为response的参数化类型呢？另外这个<code>JSON.parseObject</code>也不是<code>Spring Framework</code>内置的<code>Jackson</code>啊，仔细一看原来是我天朝上国的<a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a>，为什么要放弃内置的Json方案而再引入一个第三方的呢？</p><p>赶紧找来开发人员小G请教原委，</p><blockquote><p>Order API Response的属性名是以大写字母开头的，<code>Jackson</code>默认不能处理，<code>fastjson</code>默认可以处理，所以引入了<code>fastjson</code>并以<code>String</code>类型接收响应。</p><footer><strong>小G的回答</strong></footer></blockquote><p>Hmmm，貌似很有道理的样子，但仔细推敲起来，至少还有其他问题，于是我回复道，</p><blockquote><ol><li>假设Order API返回10000个属性，我们只用10个，使用<code>String</code>全部接收响应，岂不是很浪费？性能是不是也不高？</li><li>假设使用<code>fastjson</code>不可避免，那么是否有更好的解决方案呢？</li></ol><footer><strong>我的回复</strong></footer></blockquote><p>开发人员G于是进入了冥思苦想状，而我的思绪也逐渐模糊，从<code>fastjson</code>转向了<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener">RestTemplate</a>。</p><h3 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h3><p>无论使用<a href="https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#spring-web" target="_blank" rel="noopener">Spring MVC</a>来做为<code>Server</code>端，还是使用<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener">RestTemplate</a>来做为<code>Clinet</code>端，<code>Spring Framework</code>都是在使用<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/HttpMessageConverter.html" target="_blank" rel="noopener">HttpMessageConverter</a>来处理http消息。</p><p><code>Spring Framework</code>内置了很多<a href="https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-message-converters" target="_blank" rel="noopener">Http Message Converters</a>，而<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/json/MappingJackson2HttpMessageConverter.html" target="_blank" rel="noopener">MappingJackson2HttpMessageConverter</a>就是内置使用<code>Jackson</code>来处理Json的Converter，假设我们要使用<code>fastjson</code>来替换<code>Jackson</code>，最好的办法是直接在替换掉<code>MappingJackson2HttpMessageConverter</code>，这样在使用<code>RestTemplate</code>来请求API时，不需要手动处理<code>response</code>的反序列化，本来，序列化方式也应该对客户端代码是透明的。那么问题来了，如何替换掉<code>MappingJackson2HttpMessageConverter</code>呢？来，动手吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApiClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> converter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">        <span class="keyword">var</span> messageConverters = <span class="keyword">this</span>.restTemplate.getMessageConverters();</span><br><span class="line">        <span class="keyword">var</span> converters = messageConverters.stream()</span><br><span class="line">                           .filter(item -&gt; !(item <span class="keyword">instanceof</span> MappingJackson2HttpMessageConverter))</span><br><span class="line">                           .collect(Collectors.toList());</span><br><span class="line">        converters.add(converter);</span><br><span class="line">        <span class="keyword">this</span>.restTemplate.setMessageConverters(converters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderApiResponse <span class="title">getOrder</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Seems better now. 开发人员G对我的这个方案很满意，且慢，我还有问题呢！</p><blockquote><ol><li>既然Spring已经内置了<code>Jackson</code>来处理Json，我们为什么要画蛇添足地引入另外一种Json处理包呢？</li><li>既然<code>fastjson</code>能做到，凭什么<code>Jackson</code>做不到呢？</li></ol><footer><strong>我的新问题</strong></footer></blockquote><p>路漫漫其修远兮，吾将上下而求索。</p><h3 id="第三种写法"><a href="#第三种写法" class="headerlink" title="第三种写法"></a>第三种写法</h3><p>在我苦苦求索不得要领之时，小R兴冲冲跑过来说道，</p><blockquote><ol><li>Jackson有对应的<code>MapperFeature</code>来支持兼容大写字母开头的属性名；</li><li>我们使用的是<code>Spring Boot</code>，可以直接使用<code>properties</code>来设置该属性，不需要额外写代码；</li></ol><footer><strong>小R的回复</strong></footer></blockquote><p>综合小R的回复，我们只需要在<code>application.properties</code>文件里，加上这么一句就好啦，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jackson.mapper.accept_case_insensitive_properties=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>So Easy, 难道不是吗？可是敏而好学，不耻下问的我，又有新问题了，</p><blockquote><ol><li>如果兼容非Java Bean规范的属性名，想必要付出额外的性能代价吧？</li><li>在我们的应用中，有很多外部API调用的场景都使用到了<code>RestTemplate</code>，但并不是所有的这些场景都需要兼容首字母大写的属性名吧？</li><li>配置在<code>application.properties</code>中的<code>mapper_feature</code>应该是全局设置，对所有的<code>RestTemplate</code>都起效吧，那岂不是说不需要兼容首字母大写的API调用在使用<code>RestTemplate</code>时也需要承担性能下降的代价？</li></ol><footer><strong>我的新问题</strong></footer></blockquote><p>显然，还得继续求索啊。</p><h3 id="第四种写法"><a href="#第四种写法" class="headerlink" title="第四种写法"></a>第四种写法</h3><p>为了不使其他使用<code>RestTemplate</code>的API Client收到全局配置的影响，那么就不能在全局配置，配置应该发生在个体之上。在这个思路的只因下，小R在<code>OrderApiClient</code>自己的<code>RestTemplate</code>上下手了，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApiClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> messageConverter = </span><br><span class="line">            <span class="keyword">this</span>.restTemplate.getMessageConverters()</span><br><span class="line">                             .stream()</span><br><span class="line">                             .filter(MappingJackson2HttpMessageConverter.class::isInstance)</span><br><span class="line">                             .map(MappingJackson2HttpMessageConverter.class::cast)</span><br><span class="line">                             .findFirst()</span><br><span class="line">                             .orElseThrow(() -&gt; <span class="keyword">new</span> RuntimeException(<span class="string">"MappingJackson2HttpMessageConverter not found"</span>));</span><br><span class="line">        </span><br><span class="line">        messageConverter.getObjectMapper().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderApiResponse <span class="title">getOrder</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好，所有的问题都解决了，需求实现了，性能还不错，更没有污染全局，小R，V5！<br>然而，既然已经走到了这里，还能更进一步吗？</p><h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><p>正如上面所说，该做到的其实都已经做到了，无以复加了。可是患有强迫症的我，仍然觉得代码在结构和写法上仍然还有可调整的空间，</p><blockquote><ol><li>我们真的需要那个<code>RuntimeException</code>吗？</li><li>基于目前的代码，所有的Converters里真的会没有找到<code>MappingJackson2HttpMessageConverter</code>？</li><li>如果以上两个问题的答案是No，那么代码是否能写的更优雅呢？</li></ol><footer><strong>我的新问题</strong></footer></blockquote><p>这次不劳烦小G和小R动手了，我来亲手把它写出来吧，更进一步之后大概是这样子的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApiClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.restTemplate.getMessageConverters()</span><br><span class="line">                         .stream()</span><br><span class="line">                         .filter(MappingJackson2HttpMessageConverter.class::isInstance)</span><br><span class="line">                         .map(MappingJackson2HttpMessageConverter.class::cast)</span><br><span class="line">                         .findFirst()</span><br><span class="line">                         .map(MappingJackson2HttpMessageConverter::getObjectMapper)</span><br><span class="line">                         .ifPresent(objectMapper -&gt; </span><br><span class="line">                         objectMapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES,<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderApiResponse <span class="title">getOrder</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，终于没有然后了。</p><h3 id="退而思之"><a href="#退而思之" class="headerlink" title="退而思之"></a>退而思之</h3><p>让我们复盘一下整个故事的发展过程，</p><ol><li>引入<code>fastjson</code>并单独使用<code>JSON.parseObject</code>来处理非标准变量名；</li><li>使用<code>fastjson</code>的<code>FastJsonHttpMessageConverter</code>来替换自带的<code>MappingJackson2HttpMessageConverter</code>；</li><li>干掉<code>fastjson</code>，在<code>application.properties</code>中配置全局的<code>mapper_feature</code>来适应非标准变量名；</li><li>直接修改<code>OrderApiClient</code>自己的<code>RestTemplate</code>的<code>mapper_feature</code>来适应非标准变量名，并避免污染全局；</li><li>让代码变得更简洁、优雅。</li></ol><p>从以上故事的发展过程，我们又可以总结出代码实现的不同等级，</p><ol><li>实现了功能，但性能一般；</li><li>实现了功能，性能尚可，但引入了不必要的依赖；</li><li>实现了功能，性能尚可，但副作用较大，污染了全局；</li><li>实现了功能，性能不错，无污染，无副作用，代码略显冗余，或可读性差；</li><li>实现了功能，性能不错，无污染，无副作用，代码简洁优雅、易读易懂。</li></ol><p>我们在做代码实现时，相信我们无一例外，都是奔着最高标准的第五点去的，没人从主观上就想写烂代码。但由于每个人的技能、经历、思考方式不同，写出的代码也自然不同，其质量也会大概率地分布在这五个等级内。我不能要求每个人写出的每行代码都是最高等级的，但我希望每行代码都能更趋近于最高标准。</p><p>为你们总结一下吧，小G，小R，新时代的我们，应该如何去写高质量的代码</p><blockquote><ol><li>首先要技术过硬，知其然亦要知其所以然；</li><li>要有全局观念和大局意识，从小处着手但从大处着眼；</li><li>多写亦要多想，学而不思则罔，思而不学则殆；</li><li>最后一点，也是最为重要的一点，对代码，一定要保留一份敬畏之心，一行代码写下去，即便不关乎个人生死，也会关乎项目存亡，不可不慎，不可不察。</li></ol><footer><strong>我的总结</strong></footer></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.codenong.com/jsd9e7ec44ab90/" target="_blank" rel="noopener">springboot2集成RestTemplate并使用fastjson序列化对象</a></li><li><a href="https://www.cnblogs.com/liaojie970/p/9396334.html" target="_blank" rel="noopener">springboot之jackson的两种配置方式</a></li><li><a href="https://stackoverflow.com/questions/30924816/make-json-payload-fields-case-insensitive-when-mapping-to-java-object-in-rest-ap" target="_blank" rel="noopener">Make JSON payload fields case insensitive when mapping to Java Object in REST API developed using SpringBoot</a></li><li><a href="https://stackoverflow.com/questions/9381665/how-can-we-configure-the-internal-jackson-mapper-when-using-resttemplate" target="_blank" rel="noopener">How can we configure the internal Jackson mapper when using RestTemplate?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%B2%81%E8%BF%85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鲁迅&lt;/a&gt;的名篇&lt;a href=&quot;https://zh.m.wikisource.org/zh-hans/%E5%AD%94%E4%B9%99%E5%B7%B1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《孔乙己》&lt;/a&gt;中，有这样一个桥段，&lt;code&gt;孔乙己&lt;/code&gt;问作者是否知道茴香豆的“茴”字，有四种写法，用于讽刺&lt;code&gt;孔乙己&lt;/code&gt;这类落魄文人的迂腐。我们在coding时，为实现某一逻辑，也会存在各种各样的方案，而每种方案的背后，除了有各自的特点之外，也或多或少与给出这些方案的人的技能、经历、思考方式有关，本文试图以亲身经历的一个小故事，来探究编程领域内茴字N种写法背后的故事。    &lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://danielpf.me/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="spring" scheme="https://danielpf.me/tags/spring/"/>
    
      <category term="resttemplate" scheme="https://danielpf.me/tags/resttemplate/"/>
    
      <category term="jackson" scheme="https://danielpf.me/tags/jackson/"/>
    
      <category term="fastjson" scheme="https://danielpf.me/tags/fastjson/"/>
    
  </entry>
  
  <entry>
    <title>Reactor技巧4则</title>
    <link href="https://danielpf.me/2020/05/03/4-reactor-tips/"/>
    <id>https://danielpf.me/2020/05/03/4-reactor-tips/</id>
    <published>2020-05-03T04:38:29.000Z</published>
    <updated>2020-11-19T06:00:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章旨在介绍一些不常用但又非常有用的<a href="https://projectreactor.io/docs/core/release/reference/#which-operator" target="_blank" rel="noopener">Reactor Operator</a>。</p><a id="more"></a><h3 id="Tip-1-filterWhen"><a href="#Tip-1-filterWhen" class="headerlink" title="Tip 1: filterWhen"></a>Tip 1: filterWhen</h3><p>与Java内置的<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/stream/package-summary.html" target="_blank" rel="noopener">Stream API</a>类似，<code>Reactor</code>也提供了<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filter-java.util.function.Predicate-" target="_blank" rel="noopener">fitler</a>操作符，用于按照某些条件来过滤元素，但该操作符并不能很好处理返回值是<a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html" target="_blank" rel="noopener">Publisher&lt;Boolean&gt;</a>的Predicate，例如希望判断某个key是否在Redis中存在，且使用Reactive的形式访问Redis，类似下面的code，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Boolean&gt; <span class="title">keyExists</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ReactiveStringRedisTemplate template = <span class="comment">//injected by container;</span></span><br><span class="line">    <span class="keyword">return</span> template.hasKey(key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filterWhen-java.util.function.Function-" target="_blank" rel="noopener">filterWhen</a>操作符就非常有用，其方法签名为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flux&lt;T&gt; <span class="title">filterWhen</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends Publisher&lt;Boolean&gt;&gt; asyncPredicate)</span></span></span><br></pre></td></tr></table></figure><p>我们可以看到用于过滤的函数由一个简单的<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/function/Predicate.html" target="_blank" rel="noopener">Predicate</a>变成了一个返回值为<a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html" target="_blank" rel="noopener">Publisher&lt;Boolean&gt;</a>的<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/function/Function.html" target="_blank" rel="noopener">Function</a>，对于上面的判断，处理起来就很自然了，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactiveStringRedisTemplate template = <span class="comment">//injected by container;</span></span><br><span class="line"></span><br><span class="line">Flux.just(<span class="string">"key1"</span>, <span class="string">"key2"</span>, <span class="string">"key3"</span>)</span><br><span class="line">    .map(key -&gt; <span class="string">"key_prefix:"</span> + key)</span><br><span class="line">    .filterWhen(template::hasKey)</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure><p>以下几点需要注意：</p><ul><li>当<a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html" target="_blank" rel="noopener">Publisher</a>的元素为empty时，等同于false;</li><li>当<a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html" target="_blank" rel="noopener">Publisher</a>为<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html" target="_blank" rel="noopener">Flux</a>时，只有第一个元素参与比较，其他元素将被忽略;</li></ul><h3 id="Tip-2-expand"><a href="#Tip-2-expand" class="headerlink" title="Tip 2: expand"></a>Tip 2: expand</h3><p>我们在日常处理各种程序逻辑时，经常会处理分页或者递归的数据，此类数据在<strong>Imperative</strong>编程模式下很容易处理，那么如何在<strong>Reactove</strong>编程模式下处理呢？其实<code>Reactor</code>为我们提供了<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expand-java.util.function.Function-" target="_blank" rel="noopener">expand</a>方法，可以方便地处理类似数据，其方法签名如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flux&lt;T&gt; <span class="title">expand</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends Publisher&lt;? extends T&gt;&gt; expander)</span></span></span><br></pre></td></tr></table></figure><p>我们只需要提供一个具备分页或者递归边界的<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/function/Function.html" target="_blank" rel="noopener">Function</a>就可以了，<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expand-java.util.function.Function-" target="_blank" rel="noopener">expand</a>会自动帮我们把数据整理到<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html" target="_blank" rel="noopener">Flux</a>中。假设我们有这样的一个方法，用于<strong>递归</strong>(<strong>分页</strong>可以理解为<strong>递归</strong>的一种特殊形式)地加载数据，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Mono&lt;String&gt; <span class="title">composeRecursively</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//A -&gt; AA -&gt; AAA</span></span><br><span class="line">    <span class="keyword">if</span> (key.length() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.empty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(key + key.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，以上代码中，’key.length() &gt;= 3’就是所谓的递归边界。当使用<code>expand</code>方法按照上面的逻辑处理<code>&quot;A&quot;, &quot;B&quot;, &quot;C&quot;</code>数据时，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">    .expand(<span class="keyword">this</span>::composeRecursively)</span><br><span class="line">    .subscribe(log::info);</span><br></pre></td></tr></table></figure><p>输出结果为，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">AA</span><br><span class="line">BB</span><br><span class="line">CC</span><br><span class="line">AAA</span><br><span class="line">BBB</span><br><span class="line">CCC</span><br></pre></td></tr></table></figure><p>我们都知道，递归的本质是对树的遍历，从上面的执行结果，我们可以看到，<code>expand</code>是按照<strong>广度优先</strong>来遍历树的，那么如果我们的程序逻辑是顺序敏感的，且希望使用<strong>深度优先</strong>来遍历呢？<code>Reactor</code>为我们提供了<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expandDeep-java.util.function.Function-" target="_blank" rel="noopener">expandDeep</a>方法，其防方法名如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flux&lt;T&gt; <span class="title">expandDeep</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends Publisher&lt;? extends T&gt;&gt; expander)</span></span></span><br></pre></td></tr></table></figure><p>当我们使用该方法处理上面的’composeRecursively’数据时，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">    .expandDeep(<span class="keyword">this</span>::composeRecursively)</span><br><span class="line">    .subscribe(log::info);</span><br></pre></td></tr></table></figure><p>输出结果变为，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">AA</span><br><span class="line">AAA</span><br><span class="line">B</span><br><span class="line">BB</span><br><span class="line">BBB</span><br><span class="line">C</span><br><span class="line">CC</span><br><span class="line">CCC</span><br></pre></td></tr></table></figure><p>由此可见，<strong>深度优先</strong>遍历的目的就达到了。</p><h3 id="Tip-3-transform-amp-as"><a href="#Tip-3-transform-amp-as" class="headerlink" title="Tip 3: transform &amp; as"></a>Tip 3: transform &amp; as</h3><p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#transform-java.util.function.Function-" target="_blank" rel="noopener">transform</a>和<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#as-java.util.function.Function-" target="_blank" rel="noopener">as</a>都属于<strong>Mutualization</strong>(字面含义为“相互化”)操作，这类操作与<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#map-java.util.function.Function-" target="_blank" rel="noopener">map</a>、<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-" target="_blank" rel="noopener">flatMap</a>等最大的区别为，前者的操作对象是<code>Publisher</code>中的<strong>元素</strong>，而后者操作的是<code>Publisher</code>的<strong>本身</strong>。<br>首先我们看一下<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#transform-java.util.function.Function-" target="_blank" rel="noopener">transform</a>的方法签名，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;V&gt; <span class="function">Flux&lt;V&gt; <span class="title">transform</span><span class="params">(Function&lt;? <span class="keyword">super</span> Flux&lt;T&gt;,? extends Publisher&lt;V&gt;&gt; transformer)</span></span></span><br></pre></td></tr></table></figure><p>我们可以看到作为参数的<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/function/Function.html" target="_blank" rel="noopener">Function</a>，其入参出参皆为<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html" target="_blank" rel="noopener">Flux</a>，而不是元素，那么我们就可以在这个<code>Function</code>中完成对<code>Flux</code>的处理或变换，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Function&lt;Flux&lt;Integer&gt;, Flux&lt;String&gt;&gt; mapAndApplySchedulers = </span><br><span class="line">    f -&gt; f.map(String::valueOf)</span><br><span class="line">          .subscribeOn(Schedulers.boundedElastic())</span><br><span class="line">          .publishOn(Schedulers.parallel());</span><br><span class="line"></span><br><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).transform(mapAndApplySchedulers).subscribe();</span><br></pre></td></tr></table></figure><p>由此可见，当我们需要处理的是<code>Flux</code>本身而不是其中的元素的时候，<code>transform</code>是最合适的选择。</p><p>我们再来看<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#as-java.util.function.Function-" target="_blank" rel="noopener">as</a>，其方法签名为，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;P&gt; <span class="function">P <span class="title">as</span><span class="params">(Function&lt;? <span class="keyword">super</span> Flux&lt;T&gt;,P&gt; transformer)</span></span></span><br></pre></td></tr></table></figure><p>与<code>transform</code>相比，其<code>Function</code>输出参数由<code>Flux</code>变成了一个<code>P</code>，不再限定为<code>Publisher</code>，而整个函数的返回值也不再限定为<code>Flux</code>，这样的逻辑使得<code>as</code>可以作为衔接多步<code>Publisher</code>操作并保持方法<strong>流式调用(fluent)</strong>风格的不二选择，请看下面的例子，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; i = Flux.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                      .map(i -&gt; i + <span class="number">2</span>)</span><br><span class="line">                      .map(i -&gt; i * <span class="number">10</span>);</span><br><span class="line">Mono&lt;String&gt; s = MathFlux.sumInt(i)</span><br><span class="line">                         .map(isum -&gt; <span class="string">"sum="</span> + isum);</span><br></pre></td></tr></table></figure><p><code>MathFlux.sumInt</code>接收一个<code>Flux&lt;Integer&gt;</code>作为参数进行后续运算，多个步骤导致这种调用方式破坏了<strong>流式调用(fluent)</strong>风格，那么使用<code>as</code>可以解决，<strong>流式调用(fluent)</strong>风格得以保留，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; s =  Flux.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                      .map(i -&gt; i + <span class="number">2</span>)</span><br><span class="line">                      .map(i -&gt; i * <span class="number">10</span>)</span><br><span class="line">                      .as(MathFlux::sumInt)</span><br><span class="line">                      .map(isum -&gt; <span class="string">"sum="</span> + isum);</span><br></pre></td></tr></table></figure><p>再看一个在<code>Spring Webflux</code>里经常出现的场景，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">handle</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = Flux.just(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">                     .map(String::toLowerCase);</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.ok().body(result, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，在第一步，产生了作为response body的result，在第二步再组装成了<code>ServerResponse</code>，<strong>流式调用(fluent)</strong>风格遭到破坏，可以使用<code>as</code>处理，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Flux.just(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">           .map(String::toLowerCase)</span><br><span class="line">           .as(f -&gt; ServerResponse.ok().body(f, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure><p>当然，使用<code>transform</code>亦可解决问题，就是稍显冗长一些，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Flux.just(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">           .map(String::toLowerCase)</span><br><span class="line">           .transform(f -&gt; ServerResponse.ok().body(f, String<span class="class">.<span class="keyword">class</span>))</span></span><br><span class="line"><span class="class">           .<span class="title">next</span>()</span>;</span><br></pre></td></tr></table></figure><p>以上代码对比，在某些场景下，我们可以把<code>as</code>理解为<code>transform + next</code>的简写方式。</p><h3 id="Tip-4-using"><a href="#Tip-4-using" class="headerlink" title="Tip 4: using"></a>Tip 4: using</h3><p><code>Reactor</code>提供及其丰富的API来创建一个<code>Publisher</code>，其中有很多方法用于桥接非Reactive的数据类型，之中比较有用的是<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromStream-java.util.stream.Stream-" target="_blank" rel="noopener">fromStream</a>，通过使用该API，可以非常容易的创建一个<code>Publisher</code>，由于<code>Stream</code>的懒运行特性，使得<code>Stream</code>作为<code>imperative</code>编程风格下的产物，却具备了先天的<code>Reactive</code>编程风格的适配能力。例如下面的代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.fromStream(Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>))</span><br><span class="line">    .map(String::toLowerCase)</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure><p>但这里又一个陷阱，并不是所有的<code>Stream</code>在使用后都不需要<code>close</code>，很多与IO或者下层资源有关的<code>Stream</code>在使用后是需要显式关闭的，或者采用等效的隐式方式关闭，例如<code>try-with-resources</code>。有两个非常典型的这一类<code>Stream</code>的例子，一个是<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/nio/file/Files.html#lines(java.nio.file.Path)" target="_blank" rel="noopener">Files.lines(Path path)</a>返回的<code>Stream</code>，另一个就是在<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-streaming" target="_blank" rel="noopener">String Data JPA</a>的Repo中返回的<code>Stream</code>。假设我们需要从文件中读取每一行并作为<code>Flux</code>的源，为了保证读取文件而产生的<code>Stream</code>可以被正确关闭，代码上要做额外的处理，而不只是使用<code>Flux.fromStream</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lines = Files.lines(Paths.get(<span class="string">"test.txt"</span>));</span><br><span class="line">Flux.fromStream(lines)</span><br><span class="line">   .filter(s -&gt; s.length() &gt; <span class="number">10</span>)</span><br><span class="line">   .map(String::toLowerCase)</span><br><span class="line">   .doFinally(signalType -&gt; lines.close())</span><br><span class="line">   .subscribe();</span><br></pre></td></tr></table></figure><p>首先肯定，以上代码可以达到目的，但仍有不足之处：</p><ol><li>破坏了<strong>流式调用(fluent)</strong>风格；</li><li>在使用<strong>副作用(side-effect)</strong>来处理<code>Publisher</code>外部的资源。</li></ol><p>那么如何可以比较优雅地关闭<code>Stream</code>而又避免上面的两个不足呢？答案就是<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-" target="_blank" rel="noopener">using</a>，其方法签名如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,D&gt; <span class="function">Flux&lt;T&gt; <span class="title">using</span><span class="params">(Callable&lt;? extends D&gt; resourceSupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Function&lt;? <span class="keyword">super</span> D,? extends Publisher&lt;? extends T&gt;&gt; sourceSupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Consumer&lt;? <span class="keyword">super</span> D&gt; resourceCleanup)</span></span></span><br></pre></td></tr></table></figure><p>我们可以看到，<code>using</code>方法包含3个参数，<code>resourceSupplier</code>表示一个数据源，例如产生<code>Stream</code>的各种方式；<code>sourceSupplier</code>代表一个使用该数据源产生<code>Publisher</code>的一个函数，例如<code>Flux.fromStream()</code>，最后一个<code>resourceCleanup</code>代表一个清理回调，可以清理由<code>resourceSupplier</code>产生的数据源。OK，一切水到渠成啦，用<code>using</code>改写文件读取的例子，如下面的代码所示，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.using(() -&gt; Files.lines(Paths.get(<span class="string">"test.txt"</span>)), Flux::fromStream, BaseStream::close)</span><br><span class="line">    .filter(s -&gt; s.length() &gt; <span class="number">10</span>)</span><br><span class="line">    .map(String::toLowerCase)</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure><p>如代码所以，<strong>流式调用(fluent)</strong>风格得以保留，也避免了<strong>副作用(side-effect)</strong>。<code>using</code>还有更复杂的方式，<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-java.util.function.Function-" target="_blank" rel="noopener">usingWhen</a>，请自行参考文档。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Reactor</code>所提供的API及其丰富，如套用<code>Java Stream</code>API的部分理念，对于大部分API，相对容易理解，而真正难于掌握的，是在<code>Reactive</code>编程风格的大前提下，产生的<code>Reactive</code>独有的方法及其操作风格。本篇文章只是介绍了在日常的使用过程中，沉淀下来的几个例子，虽不常用，但在某些场景下，却非常有用，甚至不容易被其他方式替代。相信在项目的驱动下，在使用<code>Reactive</code>编程风格及<code>Reactor API</code>的过程中，还会遇到新的问题和挑战，如有积累，会再找机会与大家分享。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://stackoverflow.com/questions/47348706/compose-vs-transform-vs-as-vs-map-in-flux-and-mono" target="_blank" rel="noopener">compose() vs. transform() vs. as() vs. map() in Flux and Mono</a></li><li><a href="https://www.logicbig.com/tutorials/misc/reactive-programming/reactor/transform-operation.html" target="_blank" rel="noopener">Reactor - Using transform Operation</a></li><li><a href="https://simonbasle.github.io/2017/10/file-reading-in-reactor/" target="_blank" rel="noopener">File Reading in Reactor</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章旨在介绍一些不常用但又非常有用的&lt;a href=&quot;https://projectreactor.io/docs/core/release/reference/#which-operator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reactor Operator&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="https://danielpf.me/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="reactor" scheme="https://danielpf.me/tags/reactor/"/>
    
      <category term="reactive" scheme="https://danielpf.me/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>简单实现微软Teams的logback appender</title>
    <link href="https://danielpf.me/2020/04/08/logback-msteams-appender-plus/"/>
    <id>https://danielpf.me/2020/04/08/logback-msteams-appender-plus/</id>
    <published>2020-04-08T12:15:15.000Z</published>
    <updated>2020-04-08T14:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>不得不承认，微软的Teams聊天软件借(chao)鉴(xi)了很多Slack的理念，凭借其庞大的用户群体以及产品生态优势，使Teams在短时间内得以快速发展和推广。与其他消息工具类似，Teams也提供了webhook，使用它可以很容易地拓展Teams的功能，使其不仅限于一个聊天软件，更可以使其变成一个消息门户。今天我们就实现一个logback appender，使Teams可以显示应用程序的报警通知。</p><a id="more"></a><h3 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h3><p>在Teams中Connectors是用来与外部应用程序沟通的重要媒介，而Incoming webhooks就是一种特殊的Connector， 它本质上就是一个唯一的URL，可以通过向这个URL来post一组JSON信息，来达到与Teams沟通协作的目的。关于Teams中Connector与webhook的更多介绍，可以参考<a href="https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/what-are-webhooks-and-connectors" target="_blank" rel="noopener">这里</a>。</p><p>在开始向Teams发送日志之前，我们应该准备好webhook，创建webhook很简单，大概就是下面的几个步骤，</p><ol><li>首先在希望展示log信息的聊天群组中新建一个channel;</li><li>配置这个channel的Connectors，添加一个Incoming Webhook;</li><li>可以给这个webhook配置一个独特的头像，也可以使用默认;</li><li>拷贝生成的webhook URL备用。</li></ol><p>关于创建webhook的详细步骤，可以参考<a href="https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/add-incoming-webhook" target="_blank" rel="noopener">这里</a>。</p><h3 id="Message-Card"><a href="#Message-Card" class="headerlink" title="Message Card"></a>Message Card</h3><p>发送至Teams的JSON结构要遵守<a href="https://docs.microsoft.com/en-us/microsoftteams/platform/task-modules-and-cards/cards/cards-reference#office-365-connector-card" target="_blank" rel="noopener">office-365-connector-card</a>的约束，这里我们只采用Cards中相对简单的<strong>Message Card</strong>来作为消息的载体，其JSON结构类似于，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"@type"</span>: <span class="string">"MessageCard"</span>,</span><br><span class="line">    <span class="attr">"@context"</span>: <span class="string">"http://schema.org/extensions"</span>,</span><br><span class="line">    <span class="attr">"themeColor"</span>: <span class="string">"0076D7"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"Larry Bryant created a new task"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Let's do it"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助于Lombok与Jackson，<strong>MessageCard</strong> 的实现非常简单，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"@type"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type = <span class="string">"MessageCard"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"@context"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String context = <span class="string">"http://schema.org/extensions"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String themeColor;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Http客户端"><a href="#Http客户端" class="headerlink" title="Http客户端"></a>Http客户端</h3><p>前面已经讲到，Teams中的消息是来自于POST到webhook的MessageCard的JSON，所以挑选一个合适的http客户端就非常的重要，我们希望这个http客户端能够具备以下特性：</p><ol><li>高性能（不解释）;</li><li>少依赖（我们自然不希望一个logback appender还有一大堆的依赖）;</li><li>全特性（至少能够支持配置代理等特性，毕竟发送日志的应用不一定能够直接请求到webhook）;</li></ol><p>按照以上的要求，这里我们选择OkHttp，以上3点都可以满足。下面的代码段展示如何根据配置参数构建一个http client，支持以下属性：</p><ul><li>连接超时;</li><li>读写超时;</li><li>代理和代理凭据;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient okHttpClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MsTeamsAppender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient.Builder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Timeout Setting</span></span><br><span class="line">    builder.connectTimeout(connectTimeout, TimeUnit.MILLISECONDS)</span><br><span class="line">           .writeTimeout(writeTimeout, TimeUnit.MILLISECONDS)</span><br><span class="line">           .readTimeout(readTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Proxy Setting</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(proxyHost) &amp;&amp; Objects.nonNull(proxyPassword)) &#123;</span><br><span class="line">        builder.proxy(<span class="keyword">new</span> Proxy(Proxy.Type.HTTP, <span class="keyword">new</span> InetSocketAddress(proxyHost, proxyPort)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Proxy Authentication Setting</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(proxyUsername) &amp;&amp; Objects.nonNull(proxyPassword)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Authenticator proxyAuthenticator = (route, response) -&gt; &#123;</span><br><span class="line">            String credential = Credentials.basic(proxyUsername, proxyPassword);</span><br><span class="line">            <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">                           .header(<span class="string">"Proxy-Authorization"</span>, credential)</span><br><span class="line">                           .build();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        builder.proxyAuthenticator(proxyAuthenticator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.okHttpClient = builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中的 <em>connectTimeout<em>、</em>writeTimeout<em>、</em>readTimeout<em>、</em>proxyHost<em>、</em>proxyPort<em>、</em>proxyUsername<em>、</em>proxyPassword</em> 均来自于logback的配置文件。</p><h3 id="消息内容的结构与样式"><a href="#消息内容的结构与样式" class="headerlink" title="消息内容的结构与样式"></a>消息内容的结构与样式</h3><p>在Teams中显示系统异常信息，其主要目的还是为了提醒或者是报警，而不是用Teams来替代系统日志。当出现异常时，我们可以通过Teams的信息快速了解到报错的摘要，进而判断紧急程度，如果需要采取进一步的分析，仍然需要通过其他技术手段来查看详细日志，例如日志文件或者ELK。无论从业务需求或是性能需求看，发送到Teams的消息应该尽可能的简单高效，一目了然。<br>基于以上目的，我们用下面的结构与样式来表现一个消息的内容，</p><ul><li><p>title</p><ul><li>prefix(可选), 标题前缀会自动被[]包围，用来展示Server或者Appliation的名称，当然也可以直接指定环境profiel，例如staging、prod等;</li><li>title body, 出错日志的message部分，能够非常直观的了解到报错的消息内容，例如<code>log.error(&quot;error occurred when processing request&quot;, e)</code>, 那么title body就是 <strong>error occurred when processing request</strong> ;</li></ul></li><li><p>body</p><ul><li>logger name, 输出这个日志的logger，一般是一个class的全名;</li><li>formatted message, 相当于Exception的名称和Error Message，假设抛出异常的代码是<code>new IllegalStateException(&quot;OPS! You are not so good...&quot;)</code>, 那么输出的消息就是 <strong>java.lang.IllegalStateException: OPS! You are not so good…</strong>;</li><li>exceptoin stack trace, 由于异常的stack trace往往都很长，这里我们会加以限制，最多打印N行，默认N=5，超出部分用 <strong>…</strong> 来代替；</li></ul><p>基于以上定义，如果抛出一个<code>new IllegalStateException(&quot;OPS! You are not so good...&quot;)</code>异常且被<code>log.error(&quot;error occurred when processing request&quot;, e)</code>捕获，在Teams中显示的消息格式大概就是酱紫，</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/teams-demo.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><p>logback中，消息来源于 <strong>ILoggingEvent</strong> ，通过这个对象，我们可以获取到上面title与body所需的所有信息，由于 <strong>ILoggingEvent</strong> 是一个interface，我们需要把它cast成具体的实现类从而获得更多的属性，详细代码如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MessageCard <span class="title">buildMessage</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder titleBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(<span class="keyword">this</span>.titlePrefix) &amp;&amp; !<span class="string">""</span>.equals(<span class="keyword">this</span>.titlePrefix)) &#123;</span><br><span class="line">        titleBuilder.append(<span class="string">"["</span>).append(titlePrefix).append(<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    titleBuilder.append(event.getFormattedMessage());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    StringBuilder bodyBuilder = <span class="keyword">new</span> StringBuilder(event.getLoggerName());</span><br><span class="line"></span><br><span class="line">    Optional.ofNullable(event.getThrowableProxy())</span><br><span class="line">            .map(ThrowableProxy.class::cast)</span><br><span class="line">            .flatMap(throwableProxy -&gt; Optional.ofNullable(throwableProxy.getThrowable()))</span><br><span class="line">            .ifPresent(throwable -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                bodyBuilder.append(<span class="string">" - "</span>).append(throwable.toString());</span><br><span class="line"></span><br><span class="line">                StackTraceElement[] elements = throwable.getStackTrace();</span><br><span class="line"></span><br><span class="line">                Function&lt;StackTraceElement, String&gt; mapper = traceElement -&gt; <span class="string">"\tat "</span> + traceElement;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Stream&lt;String&gt; traces = elements.length &gt;= <span class="keyword">this</span>.stackTraceLines ?</span><br><span class="line">                        Stream.concat(Stream.of(elements)</span><br><span class="line">                                            .limit(<span class="keyword">this</span>.stackTraceLines)</span><br><span class="line">                                            .map(mapper),</span><br><span class="line">                                      Stream.of(<span class="string">"\tat ..."</span>)) : Stream.of(elements).map(mapper);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> String stackTrace = traces.collect(Collectors.joining(<span class="string">"\n"</span>));</span><br><span class="line"></span><br><span class="line">                bodyBuilder.append(<span class="string">"&lt;br&gt;&lt;pre&gt;"</span>).append(stackTrace).append(<span class="string">"&lt;/pre&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MessageCard.builder()</span><br><span class="line">                      .title(titleBuilder.toString())</span><br><span class="line">                      .text(bodyBuilder.toString())</span><br><span class="line">                      .themeColor(getThemeColorByLevel(event.getLevel()))</span><br><span class="line">                      .build();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限制与缺点"><a href="#限制与缺点" class="headerlink" title="限制与缺点"></a>限制与缺点</h3><p>虽说Teams为我们提供了webhook的方式，但这种其终究还是一个企业级聊天平台，而非一个集中日志系统，而Connctors本身，也有一定的QPS限制，并不能及时处理海量的日志或报警，试想一下我们的系统采用大规模的集群部署或者容器化部署，在短时间内可能会产生大量的错误报警，这个时候对于Teams Connector的冲击还是非常大的。<br>Connector的QPS限制可以参考<a href="https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/connectors-using#rate-limiting-for-connectors" target="_blank" rel="noopener">这里</a>。</p><p>所以在某些场景下，直接使用logback appender向Teams发送消息并不是一个非常好的选择，可以适当考虑采用ELK等集中式日志管理平台来收集日志，在出发某些特定条件，再由日志平台向Teams转发消息。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>请参考<br><a href="https://github.com/dipengfei/logback-msteams-appender-plus" target="_blank" rel="noopener">logback-msteams-appender-plus</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不得不承认，微软的Teams聊天软件借(chao)鉴(xi)了很多Slack的理念，凭借其庞大的用户群体以及产品生态优势，使Teams在短时间内得以快速发展和推广。与其他消息工具类似，Teams也提供了webhook，使用它可以很容易地拓展Teams的功能，使其不仅限于一个聊天软件，更可以使其变成一个消息门户。今天我们就实现一个logback appender，使Teams可以显示应用程序的报警通知。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实践" scheme="https://danielpf.me/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="logback" scheme="https://danielpf.me/tags/logback/"/>
    
      <category term="httpclient" scheme="https://danielpf.me/tags/httpclient/"/>
    
  </entry>
  
  <entry>
    <title>2020，重启博客于早春</title>
    <link href="https://danielpf.me/2020/04/06/kickoff2020/"/>
    <id>https://danielpf.me/2020/04/06/kickoff2020/</id>
    <published>2020-04-06T12:02:59.000Z</published>
    <updated>2020-04-06T12:59:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>早在2017年，就申请了这个域名，也写下来了第一篇hexo博客，记得是使用Java 8 Stream来打印乘法口诀的，说来惭愧，之后再没有了更新。随着职业生涯的推进，感觉还是应该在某处记录下经历过的点点滴滴，也不枉费将所有的青春年华大都贡献给了架构和代码，希望自己笔耕不辍，能多留下一些足迹。</p><a id="more"></a><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>文章大概分成下面大类，</p><ul><li>技巧，主要关注于某些产品或框架的特定使用，例如Java 8中的Collectors，以及Spring中的RestTemplate；</li><li>实践，主要以一个完整的项目或者用例，来实现某一个特定的功能，例如Reactive Messaging System，以及微软Teams的logback appender；</li><li>杂谈，非具体技术类主题，可能会涉及思考方式、团队管理等。</li></ul><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>依据以上分类，我会在我的<a href="https://github.com/dipengfei" target="_blank" rel="noopener">github</a>上维护一些项目，这些项目包括</p><ul><li>技巧类项目，暂时想规划下面的几个<ul><li><a href="https://github.com/dipengfei/new-age-java" target="_blank" rel="noopener">new-age-java</a>，新时代Java，主要介绍Java 8以后新特性的使用；</li><li><a href="https://github.com/dipengfei/spring-plain-tips" target="_blank" rel="noopener">spring-plain-tips</a>，非Reactive的Spring Framework和Spring Boot的使用技巧；</li><li><a href="https://github.com/dipengfei/spring-reactive-tips" target="_blank" rel="noopener">spring-reactive-tips</a>，Reactive的Spring Framework和Spring Boot的使用技巧；</li></ul></li><li>实践类项目，每个实践主题都会有一个新建的项目与之对应，目前有几个比较成型的，以后会陆续增加，<ul><li><a href="https://github.com/dipengfei/logback-msteams-appender-plus" target="_blank" rel="noopener">logback-msteams-appender-plus</a>，实现了一个微软Teams的logback appender，可以向Teams聊天软件发送日志信息；</li><li><a href="https://github.com/dipengfei/reactive-messaging-play" target="_blank" rel="noopener">reactive-messaging-play</a>，实现了一个full reactive的end-to-end的消息服务；</li><li><a href="https://github.com/dipengfei/cloud-gateway-auth2-play" target="_blank" rel="noopener">cloud-gateway-auth2-play</a>，实现了基于Spring Cloud Gateway的OAuth2鉴权；</li></ul></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>也不知道自己是否能坚持下去，尽人事听天命，但行好事莫问前程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在2017年，就申请了这个域名，也写下来了第一篇hexo博客，记得是使用Java 8 Stream来打印乘法口诀的，说来惭愧，之后再没有了更新。随着职业生涯的推进，感觉还是应该在某处记录下经历过的点点滴滴，也不枉费将所有的青春年华大都贡献给了架构和代码，希望自己笔耕不辍，能多留下一些足迹。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://danielpf.me/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
